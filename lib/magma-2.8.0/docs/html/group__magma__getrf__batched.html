<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MAGMA: getrf: LU factorization</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="magma-logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">MAGMA<span id="projectnumber">&#160;2.8.0</span>
   </div>
   <div id="projectbrief">Matrix Algebra for GPU and Multicore Architectures</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__magma__getrf__batched.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">getrf: LU factorization<div class="ingroups"><a class="el" href="group__batched.html">Batched</a> &raquo; <a class="el" href="group__group__solvers__batched.html">Linear system solvers</a> &raquo; <a class="el" href="group__group__gesv__batched.html">General matrices: LU</a></div></div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga850c86b299cb8d37d201299ec739aae9"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__getrf__batched.html#ga850c86b299cb8d37d201299ec739aae9">magma_cgbsv_batched_work</a> (magma_int_t n, magma_int_t kl, magma_int_t ku, magma_int_t nrhs, magmaFloatComplex **dA_array, magma_int_t ldda, magma_int_t **dipiv_array, magmaFloatComplex **dB_array, magma_int_t lddb, magma_int_t *info_array, void *device_work, magma_int_t *lwork, magma_int_t batchCount, <a class="el" href="structmagma__queue.html">magma_queue_t</a> queue)</td></tr>
<tr class="memdesc:ga850c86b299cb8d37d201299ec739aae9"><td class="mdescLeft">&#160;</td><td class="mdescRight">CGBSV computes the solution to a system of linear equations A * X = B, where A is a band matrix of order N with KL subdiagonals and KU superdiagonals, and X and B are N-by-NRHS matrices.  <br /></td></tr>
<tr class="separator:ga850c86b299cb8d37d201299ec739aae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8022b4ce3bacbb81faa5db0f22c7f6d9"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__getrf__batched.html#ga8022b4ce3bacbb81faa5db0f22c7f6d9">magma_cgbsv_batched</a> (magma_int_t n, magma_int_t kl, magma_int_t ku, magma_int_t nrhs, magmaFloatComplex **dA_array, magma_int_t ldda, magma_int_t **dipiv_array, magmaFloatComplex **dB_array, magma_int_t lddb, magma_int_t *info_array, magma_int_t batchCount, <a class="el" href="structmagma__queue.html">magma_queue_t</a> queue)</td></tr>
<tr class="memdesc:ga8022b4ce3bacbb81faa5db0f22c7f6d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">CGBSV computes the solution to a system of linear equations A * X = B, where A is a band matrix of order N with KL subdiagonals and KU superdiagonals, and X and B are N-by-NRHS matrices.  <br /></td></tr>
<tr class="separator:ga8022b4ce3bacbb81faa5db0f22c7f6d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c61b55f5b33597f7daf13081ffe4e78"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__getrf__batched.html#ga6c61b55f5b33597f7daf13081ffe4e78">magma_cgbtrf_batched_work</a> (magma_int_t m, magma_int_t n, magma_int_t kl, magma_int_t ku, magmaFloatComplex **dAB_array, magma_int_t lddab, magma_int_t **dipiv_array, magma_int_t *info_array, void *device_work, magma_int_t *lwork, magma_int_t batchCount, <a class="el" href="structmagma__queue.html">magma_queue_t</a> queue)</td></tr>
<tr class="memdesc:ga6c61b55f5b33597f7daf13081ffe4e78"><td class="mdescLeft">&#160;</td><td class="mdescRight">CGBTRF computes an LU factorization of a complex m-by-n band matrix AB using partial pivoting with row interchanges.  <br /></td></tr>
<tr class="separator:ga6c61b55f5b33597f7daf13081ffe4e78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53418c8cc29eddbb54f9fb52e6f66e88"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__getrf__batched.html#ga53418c8cc29eddbb54f9fb52e6f66e88">magma_cgbtrf_batched</a> (magma_int_t m, magma_int_t n, magma_int_t kl, magma_int_t ku, magmaFloatComplex **dAB_array, magma_int_t lddab, magma_int_t **dipiv_array, magma_int_t *info_array, magma_int_t batchCount, <a class="el" href="structmagma__queue.html">magma_queue_t</a> queue)</td></tr>
<tr class="memdesc:ga53418c8cc29eddbb54f9fb52e6f66e88"><td class="mdescLeft">&#160;</td><td class="mdescRight">CGBTRF computes an LU factorization of a COMPLEX m-by-n band matrix A using partial pivoting with row interchanges.  <br /></td></tr>
<tr class="separator:ga53418c8cc29eddbb54f9fb52e6f66e88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed2b56b3482b185a8fb6a4ad52461aa9"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__getrf__batched.html#gaed2b56b3482b185a8fb6a4ad52461aa9">magma_cgbtrs_batched</a> (magma_trans_t transA, magma_int_t n, magma_int_t kl, magma_int_t ku, magma_int_t nrhs, magmaFloatComplex **dA_array, magma_int_t ldda, magma_int_t **dipiv_array, magmaFloatComplex **dB_array, magma_int_t lddb, magma_int_t *info_array, magma_int_t batchCount, <a class="el" href="structmagma__queue.html">magma_queue_t</a> queue)</td></tr>
<tr class="memdesc:gaed2b56b3482b185a8fb6a4ad52461aa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">CGBTRS solves a system of linear equations A * X = B, A**T * X = B, or A**H * X = B with a general band matrix A using the LU factorization computed by CGBTRF.  <br /></td></tr>
<tr class="separator:gaed2b56b3482b185a8fb6a4ad52461aa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5d0dfc5179e4ff7dd34971c885afb79"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__getrf__batched.html#gac5d0dfc5179e4ff7dd34971c885afb79">magma_cgetrf_batched</a> (magma_int_t m, magma_int_t n, magmaFloatComplex **dA_array, magma_int_t ldda, magma_int_t **ipiv_array, magma_int_t *info_array, magma_int_t batchCount, <a class="el" href="structmagma__queue.html">magma_queue_t</a> queue)</td></tr>
<tr class="memdesc:gac5d0dfc5179e4ff7dd34971c885afb79"><td class="mdescLeft">&#160;</td><td class="mdescRight">CGETRF computes an LU factorization of a general M-by-N matrix A using partial pivoting with row interchanges.  <br /></td></tr>
<tr class="separator:gac5d0dfc5179e4ff7dd34971c885afb79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga188b8b2cebe437eb093f504dd7ce69f3"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__getrf__batched.html#ga188b8b2cebe437eb093f504dd7ce69f3">magma_cgetrf_recpanel_batched</a> (magma_int_t m, magma_int_t n, magma_int_t min_recpnb, magmaFloatComplex **dA_array, magma_int_t ai, magma_int_t aj, magma_int_t ldda, magma_int_t **dipiv_array, magma_int_t **dpivinfo_array, magma_int_t *info_array, magma_int_t gbstep, magma_int_t batchCount, <a class="el" href="structmagma__queue.html">magma_queue_t</a> queue)</td></tr>
<tr class="memdesc:ga188b8b2cebe437eb093f504dd7ce69f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an internal routine that might have many assumption.  <br /></td></tr>
<tr class="separator:ga188b8b2cebe437eb093f504dd7ce69f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e1771f88d0042c0e8789019c3aad7a3"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__getrf__batched.html#ga4e1771f88d0042c0e8789019c3aad7a3">magma_cgetrf_recpanel_native</a> (magma_int_t m, magma_int_t n, magma_int_t recnb, magmaFloatComplex_ptr dA, magma_int_t ldda, magma_int_t *dipiv, magma_int_t *dipivinfo, magma_int_t *dinfo, magma_int_t gbstep, magma_event_t events[2], <a class="el" href="structmagma__queue.html">magma_queue_t</a> queue, <a class="el" href="structmagma__queue.html">magma_queue_t</a> update_queue)</td></tr>
<tr class="memdesc:ga4e1771f88d0042c0e8789019c3aad7a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an internal routine.  <br /></td></tr>
<tr class="separator:ga4e1771f88d0042c0e8789019c3aad7a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga284a4d90f1fb206aded3ca9462018013"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__getrf__batched.html#ga284a4d90f1fb206aded3ca9462018013">magma_cgetrf_vbatched_max_nocheck_work</a> (magma_int_t *m, magma_int_t *n, magma_int_t max_m, magma_int_t max_n, magma_int_t max_minmn, magma_int_t max_mxn, magmaFloatComplex **dA_array, magma_int_t *ldda, magma_int_t **dipiv_array, magma_int_t *info_array, void *work, magma_int_t *lwork, magma_int_t batchCount, <a class="el" href="structmagma__queue.html">magma_queue_t</a> queue)</td></tr>
<tr class="memdesc:ga284a4d90f1fb206aded3ca9462018013"><td class="mdescLeft">&#160;</td><td class="mdescRight">CGETRF computes an LU factorization of a general M-by-N matrix A using partial pivoting with row interchanges.  <br /></td></tr>
<tr class="separator:ga284a4d90f1fb206aded3ca9462018013"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61698c835989a877fcda119b0abb0b57"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__getrf__batched.html#ga61698c835989a877fcda119b0abb0b57">magma_cgetrf_vbatched</a> (magma_int_t *m, magma_int_t *n, magmaFloatComplex **dA_array, magma_int_t *ldda, magma_int_t **dipiv_array, magma_int_t *info_array, magma_int_t batchCount, <a class="el" href="structmagma__queue.html">magma_queue_t</a> queue)</td></tr>
<tr class="memdesc:ga61698c835989a877fcda119b0abb0b57"><td class="mdescLeft">&#160;</td><td class="mdescRight">CGETRF computes an LU factorization of a general M-by-N matrix A using partial pivoting with row interchanges.  <br /></td></tr>
<tr class="separator:ga61698c835989a877fcda119b0abb0b57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f7298c3914756779363587a9d45fc4e"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__getrf__batched.html#ga2f7298c3914756779363587a9d45fc4e">magma_dgbsv_batched_work</a> (magma_int_t n, magma_int_t kl, magma_int_t ku, magma_int_t nrhs, double **dA_array, magma_int_t ldda, magma_int_t **dipiv_array, double **dB_array, magma_int_t lddb, magma_int_t *info_array, void *device_work, magma_int_t *lwork, magma_int_t batchCount, <a class="el" href="structmagma__queue.html">magma_queue_t</a> queue)</td></tr>
<tr class="memdesc:ga2f7298c3914756779363587a9d45fc4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">DGBSV computes the solution to a system of linear equations A * X = B, where A is a band matrix of order N with KL subdiagonals and KU superdiagonals, and X and B are N-by-NRHS matrices.  <br /></td></tr>
<tr class="separator:ga2f7298c3914756779363587a9d45fc4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa422d21f8fb016cc65f4a9e05cbd9c7f"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__getrf__batched.html#gaa422d21f8fb016cc65f4a9e05cbd9c7f">magma_dgbsv_batched</a> (magma_int_t n, magma_int_t kl, magma_int_t ku, magma_int_t nrhs, double **dA_array, magma_int_t ldda, magma_int_t **dipiv_array, double **dB_array, magma_int_t lddb, magma_int_t *info_array, magma_int_t batchCount, <a class="el" href="structmagma__queue.html">magma_queue_t</a> queue)</td></tr>
<tr class="memdesc:gaa422d21f8fb016cc65f4a9e05cbd9c7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">DGBSV computes the solution to a system of linear equations A * X = B, where A is a band matrix of order N with KL subdiagonals and KU superdiagonals, and X and B are N-by-NRHS matrices.  <br /></td></tr>
<tr class="separator:gaa422d21f8fb016cc65f4a9e05cbd9c7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0b9bd7edf6e8fdbf0fd94ea4a11f97e"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__getrf__batched.html#gaa0b9bd7edf6e8fdbf0fd94ea4a11f97e">magma_dgbtrf_batched_work</a> (magma_int_t m, magma_int_t n, magma_int_t kl, magma_int_t ku, double **dAB_array, magma_int_t lddab, magma_int_t **dipiv_array, magma_int_t *info_array, void *device_work, magma_int_t *lwork, magma_int_t batchCount, <a class="el" href="structmagma__queue.html">magma_queue_t</a> queue)</td></tr>
<tr class="memdesc:gaa0b9bd7edf6e8fdbf0fd94ea4a11f97e"><td class="mdescLeft">&#160;</td><td class="mdescRight">DGBTRF computes an LU factorization of a real m-by-n band matrix AB using partial pivoting with row interchanges.  <br /></td></tr>
<tr class="separator:gaa0b9bd7edf6e8fdbf0fd94ea4a11f97e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga192b742fccb2bbdb4d7dcb5f3d1f349a"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__getrf__batched.html#ga192b742fccb2bbdb4d7dcb5f3d1f349a">magma_dgbtrf_batched</a> (magma_int_t m, magma_int_t n, magma_int_t kl, magma_int_t ku, double **dAB_array, magma_int_t lddab, magma_int_t **dipiv_array, magma_int_t *info_array, magma_int_t batchCount, <a class="el" href="structmagma__queue.html">magma_queue_t</a> queue)</td></tr>
<tr class="memdesc:ga192b742fccb2bbdb4d7dcb5f3d1f349a"><td class="mdescLeft">&#160;</td><td class="mdescRight">DGBTRF computes an LU factorization of a COMPLEX m-by-n band matrix A using partial pivoting with row interchanges.  <br /></td></tr>
<tr class="separator:ga192b742fccb2bbdb4d7dcb5f3d1f349a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc4f87c8d102b2cdc6a93a16e865db56"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__getrf__batched.html#gabc4f87c8d102b2cdc6a93a16e865db56">magma_dgbtrs_batched</a> (magma_trans_t transA, magma_int_t n, magma_int_t kl, magma_int_t ku, magma_int_t nrhs, double **dA_array, magma_int_t ldda, magma_int_t **dipiv_array, double **dB_array, magma_int_t lddb, magma_int_t *info_array, magma_int_t batchCount, <a class="el" href="structmagma__queue.html">magma_queue_t</a> queue)</td></tr>
<tr class="memdesc:gabc4f87c8d102b2cdc6a93a16e865db56"><td class="mdescLeft">&#160;</td><td class="mdescRight">DGBTRS solves a system of linear equations A * X = B, A**T * X = B, or A**H * X = B with a general band matrix A using the LU factorization computed by DGBTRF.  <br /></td></tr>
<tr class="separator:gabc4f87c8d102b2cdc6a93a16e865db56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c8feaafa83444639c86779e42510298"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__getrf__batched.html#ga3c8feaafa83444639c86779e42510298">magma_dgetrf_batched</a> (magma_int_t m, magma_int_t n, double **dA_array, magma_int_t ldda, magma_int_t **ipiv_array, magma_int_t *info_array, magma_int_t batchCount, <a class="el" href="structmagma__queue.html">magma_queue_t</a> queue)</td></tr>
<tr class="memdesc:ga3c8feaafa83444639c86779e42510298"><td class="mdescLeft">&#160;</td><td class="mdescRight">DGETRF computes an LU factorization of a general M-by-N matrix A using partial pivoting with row interchanges.  <br /></td></tr>
<tr class="separator:ga3c8feaafa83444639c86779e42510298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4efed876a89ed9400560027dac193473"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__getrf__batched.html#ga4efed876a89ed9400560027dac193473">magma_dgetrf_recpanel_batched</a> (magma_int_t m, magma_int_t n, magma_int_t min_recpnb, double **dA_array, magma_int_t ai, magma_int_t aj, magma_int_t ldda, magma_int_t **dipiv_array, magma_int_t **dpivinfo_array, magma_int_t *info_array, magma_int_t gbstep, magma_int_t batchCount, <a class="el" href="structmagma__queue.html">magma_queue_t</a> queue)</td></tr>
<tr class="memdesc:ga4efed876a89ed9400560027dac193473"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an internal routine that might have many assumption.  <br /></td></tr>
<tr class="separator:ga4efed876a89ed9400560027dac193473"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43f4d978c91ab804c0267cfc909ebd10"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__getrf__batched.html#ga43f4d978c91ab804c0267cfc909ebd10">magma_dgetrf_recpanel_native</a> (magma_int_t m, magma_int_t n, magma_int_t recnb, magmaDouble_ptr dA, magma_int_t ldda, magma_int_t *dipiv, magma_int_t *dipivinfo, magma_int_t *dinfo, magma_int_t gbstep, magma_event_t events[2], <a class="el" href="structmagma__queue.html">magma_queue_t</a> queue, <a class="el" href="structmagma__queue.html">magma_queue_t</a> update_queue)</td></tr>
<tr class="memdesc:ga43f4d978c91ab804c0267cfc909ebd10"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an internal routine.  <br /></td></tr>
<tr class="separator:ga43f4d978c91ab804c0267cfc909ebd10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga606dea50c55fe82d7192b7691d4dd4d6"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__getrf__batched.html#ga606dea50c55fe82d7192b7691d4dd4d6">magma_dgetrf_vbatched_max_nocheck_work</a> (magma_int_t *m, magma_int_t *n, magma_int_t max_m, magma_int_t max_n, magma_int_t max_minmn, magma_int_t max_mxn, double **dA_array, magma_int_t *ldda, magma_int_t **dipiv_array, magma_int_t *info_array, void *work, magma_int_t *lwork, magma_int_t batchCount, <a class="el" href="structmagma__queue.html">magma_queue_t</a> queue)</td></tr>
<tr class="memdesc:ga606dea50c55fe82d7192b7691d4dd4d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">DGETRF computes an LU factorization of a general M-by-N matrix A using partial pivoting with row interchanges.  <br /></td></tr>
<tr class="separator:ga606dea50c55fe82d7192b7691d4dd4d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace18ffd8f99c360904a4b6e2c088ea7c"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__getrf__batched.html#gace18ffd8f99c360904a4b6e2c088ea7c">magma_dgetrf_vbatched</a> (magma_int_t *m, magma_int_t *n, double **dA_array, magma_int_t *ldda, magma_int_t **dipiv_array, magma_int_t *info_array, magma_int_t batchCount, <a class="el" href="structmagma__queue.html">magma_queue_t</a> queue)</td></tr>
<tr class="memdesc:gace18ffd8f99c360904a4b6e2c088ea7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">DGETRF computes an LU factorization of a general M-by-N matrix A using partial pivoting with row interchanges.  <br /></td></tr>
<tr class="separator:gace18ffd8f99c360904a4b6e2c088ea7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0fa974b09ba2eeecf5e6cd207e719abf"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__getrf__batched.html#ga0fa974b09ba2eeecf5e6cd207e719abf">magma_sgbsv_batched_work</a> (magma_int_t n, magma_int_t kl, magma_int_t ku, magma_int_t nrhs, float **dA_array, magma_int_t ldda, magma_int_t **dipiv_array, float **dB_array, magma_int_t lddb, magma_int_t *info_array, void *device_work, magma_int_t *lwork, magma_int_t batchCount, <a class="el" href="structmagma__queue.html">magma_queue_t</a> queue)</td></tr>
<tr class="memdesc:ga0fa974b09ba2eeecf5e6cd207e719abf"><td class="mdescLeft">&#160;</td><td class="mdescRight">SGBSV computes the solution to a system of linear equations A * X = B, where A is a band matrix of order N with KL subdiagonals and KU superdiagonals, and X and B are N-by-NRHS matrices.  <br /></td></tr>
<tr class="separator:ga0fa974b09ba2eeecf5e6cd207e719abf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f2ae9d536a2ba061070590302a78ea1"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__getrf__batched.html#ga6f2ae9d536a2ba061070590302a78ea1">magma_sgbsv_batched</a> (magma_int_t n, magma_int_t kl, magma_int_t ku, magma_int_t nrhs, float **dA_array, magma_int_t ldda, magma_int_t **dipiv_array, float **dB_array, magma_int_t lddb, magma_int_t *info_array, magma_int_t batchCount, <a class="el" href="structmagma__queue.html">magma_queue_t</a> queue)</td></tr>
<tr class="memdesc:ga6f2ae9d536a2ba061070590302a78ea1"><td class="mdescLeft">&#160;</td><td class="mdescRight">SGBSV computes the solution to a system of linear equations A * X = B, where A is a band matrix of order N with KL subdiagonals and KU superdiagonals, and X and B are N-by-NRHS matrices.  <br /></td></tr>
<tr class="separator:ga6f2ae9d536a2ba061070590302a78ea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb4f407757f60edc4424b9df76f7438a"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__getrf__batched.html#gaeb4f407757f60edc4424b9df76f7438a">magma_sgbtrf_batched_work</a> (magma_int_t m, magma_int_t n, magma_int_t kl, magma_int_t ku, float **dAB_array, magma_int_t lddab, magma_int_t **dipiv_array, magma_int_t *info_array, void *device_work, magma_int_t *lwork, magma_int_t batchCount, <a class="el" href="structmagma__queue.html">magma_queue_t</a> queue)</td></tr>
<tr class="memdesc:gaeb4f407757f60edc4424b9df76f7438a"><td class="mdescLeft">&#160;</td><td class="mdescRight">SGBTRF computes an LU factorization of a real m-by-n band matrix AB using partial pivoting with row interchanges.  <br /></td></tr>
<tr class="separator:gaeb4f407757f60edc4424b9df76f7438a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b251813d6af1cc89478e12e45b2b41e"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__getrf__batched.html#ga0b251813d6af1cc89478e12e45b2b41e">magma_sgbtrf_batched</a> (magma_int_t m, magma_int_t n, magma_int_t kl, magma_int_t ku, float **dAB_array, magma_int_t lddab, magma_int_t **dipiv_array, magma_int_t *info_array, magma_int_t batchCount, <a class="el" href="structmagma__queue.html">magma_queue_t</a> queue)</td></tr>
<tr class="memdesc:ga0b251813d6af1cc89478e12e45b2b41e"><td class="mdescLeft">&#160;</td><td class="mdescRight">SGBTRF computes an LU factorization of a COMPLEX m-by-n band matrix A using partial pivoting with row interchanges.  <br /></td></tr>
<tr class="separator:ga0b251813d6af1cc89478e12e45b2b41e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae03279394dfe5119906556ad182b597f"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__getrf__batched.html#gae03279394dfe5119906556ad182b597f">magma_sgbtrs_batched</a> (magma_trans_t transA, magma_int_t n, magma_int_t kl, magma_int_t ku, magma_int_t nrhs, float **dA_array, magma_int_t ldda, magma_int_t **dipiv_array, float **dB_array, magma_int_t lddb, magma_int_t *info_array, magma_int_t batchCount, <a class="el" href="structmagma__queue.html">magma_queue_t</a> queue)</td></tr>
<tr class="memdesc:gae03279394dfe5119906556ad182b597f"><td class="mdescLeft">&#160;</td><td class="mdescRight">SGBTRS solves a system of linear equations A * X = B, A**T * X = B, or A**H * X = B with a general band matrix A using the LU factorization computed by SGBTRF.  <br /></td></tr>
<tr class="separator:gae03279394dfe5119906556ad182b597f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79368ca75f446be8b186683e01dfa66e"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__getrf__batched.html#ga79368ca75f446be8b186683e01dfa66e">magma_sgetrf_batched</a> (magma_int_t m, magma_int_t n, float **dA_array, magma_int_t ldda, magma_int_t **ipiv_array, magma_int_t *info_array, magma_int_t batchCount, <a class="el" href="structmagma__queue.html">magma_queue_t</a> queue)</td></tr>
<tr class="memdesc:ga79368ca75f446be8b186683e01dfa66e"><td class="mdescLeft">&#160;</td><td class="mdescRight">SGETRF computes an LU factorization of a general M-by-N matrix A using partial pivoting with row interchanges.  <br /></td></tr>
<tr class="separator:ga79368ca75f446be8b186683e01dfa66e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad535e3c1b5069535d3caf9483b712625"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__getrf__batched.html#gad535e3c1b5069535d3caf9483b712625">magma_sgetrf_recpanel_batched</a> (magma_int_t m, magma_int_t n, magma_int_t min_recpnb, float **dA_array, magma_int_t ai, magma_int_t aj, magma_int_t ldda, magma_int_t **dipiv_array, magma_int_t **dpivinfo_array, magma_int_t *info_array, magma_int_t gbstep, magma_int_t batchCount, <a class="el" href="structmagma__queue.html">magma_queue_t</a> queue)</td></tr>
<tr class="memdesc:gad535e3c1b5069535d3caf9483b712625"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an internal routine that might have many assumption.  <br /></td></tr>
<tr class="separator:gad535e3c1b5069535d3caf9483b712625"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2aeef839ebc3619efc804a667fe97b2b"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__getrf__batched.html#ga2aeef839ebc3619efc804a667fe97b2b">magma_sgetrf_recpanel_native</a> (magma_int_t m, magma_int_t n, magma_int_t recnb, magmaFloat_ptr dA, magma_int_t ldda, magma_int_t *dipiv, magma_int_t *dipivinfo, magma_int_t *dinfo, magma_int_t gbstep, magma_event_t events[2], <a class="el" href="structmagma__queue.html">magma_queue_t</a> queue, <a class="el" href="structmagma__queue.html">magma_queue_t</a> update_queue)</td></tr>
<tr class="memdesc:ga2aeef839ebc3619efc804a667fe97b2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an internal routine.  <br /></td></tr>
<tr class="separator:ga2aeef839ebc3619efc804a667fe97b2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42ec86647df5bb6554b4d7365c4689b9"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__getrf__batched.html#ga42ec86647df5bb6554b4d7365c4689b9">magma_sgetrf_vbatched_max_nocheck_work</a> (magma_int_t *m, magma_int_t *n, magma_int_t max_m, magma_int_t max_n, magma_int_t max_minmn, magma_int_t max_mxn, float **dA_array, magma_int_t *ldda, magma_int_t **dipiv_array, magma_int_t *info_array, void *work, magma_int_t *lwork, magma_int_t batchCount, <a class="el" href="structmagma__queue.html">magma_queue_t</a> queue)</td></tr>
<tr class="memdesc:ga42ec86647df5bb6554b4d7365c4689b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">SGETRF computes an LU factorization of a general M-by-N matrix A using partial pivoting with row interchanges.  <br /></td></tr>
<tr class="separator:ga42ec86647df5bb6554b4d7365c4689b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe8d59d3ca0fde9366bd671adc245198"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__getrf__batched.html#gafe8d59d3ca0fde9366bd671adc245198">magma_sgetrf_vbatched</a> (magma_int_t *m, magma_int_t *n, float **dA_array, magma_int_t *ldda, magma_int_t **dipiv_array, magma_int_t *info_array, magma_int_t batchCount, <a class="el" href="structmagma__queue.html">magma_queue_t</a> queue)</td></tr>
<tr class="memdesc:gafe8d59d3ca0fde9366bd671adc245198"><td class="mdescLeft">&#160;</td><td class="mdescRight">SGETRF computes an LU factorization of a general M-by-N matrix A using partial pivoting with row interchanges.  <br /></td></tr>
<tr class="separator:gafe8d59d3ca0fde9366bd671adc245198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86255031910bc4e5995081cb4e989b84"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__getrf__batched.html#ga86255031910bc4e5995081cb4e989b84">magma_zgbsv_batched_work</a> (magma_int_t n, magma_int_t kl, magma_int_t ku, magma_int_t nrhs, magmaDoubleComplex **dA_array, magma_int_t ldda, magma_int_t **dipiv_array, magmaDoubleComplex **dB_array, magma_int_t lddb, magma_int_t *info_array, void *device_work, magma_int_t *lwork, magma_int_t batchCount, <a class="el" href="structmagma__queue.html">magma_queue_t</a> queue)</td></tr>
<tr class="memdesc:ga86255031910bc4e5995081cb4e989b84"><td class="mdescLeft">&#160;</td><td class="mdescRight">ZGBSV computes the solution to a system of linear equations A * X = B, where A is a band matrix of order N with KL subdiagonals and KU superdiagonals, and X and B are N-by-NRHS matrices.  <br /></td></tr>
<tr class="separator:ga86255031910bc4e5995081cb4e989b84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga921d0451be70ab811ef11d19c6b9bb7e"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__getrf__batched.html#ga921d0451be70ab811ef11d19c6b9bb7e">magma_zgbsv_batched</a> (magma_int_t n, magma_int_t kl, magma_int_t ku, magma_int_t nrhs, magmaDoubleComplex **dA_array, magma_int_t ldda, magma_int_t **dipiv_array, magmaDoubleComplex **dB_array, magma_int_t lddb, magma_int_t *info_array, magma_int_t batchCount, <a class="el" href="structmagma__queue.html">magma_queue_t</a> queue)</td></tr>
<tr class="memdesc:ga921d0451be70ab811ef11d19c6b9bb7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">ZGBSV computes the solution to a system of linear equations A * X = B, where A is a band matrix of order N with KL subdiagonals and KU superdiagonals, and X and B are N-by-NRHS matrices.  <br /></td></tr>
<tr class="separator:ga921d0451be70ab811ef11d19c6b9bb7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae87b0262667fc0a402057b59f87116c4"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__getrf__batched.html#gae87b0262667fc0a402057b59f87116c4">magma_zgbtrf_batched_work</a> (magma_int_t m, magma_int_t n, magma_int_t kl, magma_int_t ku, magmaDoubleComplex **dAB_array, magma_int_t lddab, magma_int_t **dipiv_array, magma_int_t *info_array, void *device_work, magma_int_t *lwork, magma_int_t batchCount, <a class="el" href="structmagma__queue.html">magma_queue_t</a> queue)</td></tr>
<tr class="memdesc:gae87b0262667fc0a402057b59f87116c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">ZGBTRF computes an LU factorization of a complex m-by-n band matrix AB using partial pivoting with row interchanges.  <br /></td></tr>
<tr class="separator:gae87b0262667fc0a402057b59f87116c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6fc579f5d372dd13ed6ef863b369bd5"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__getrf__batched.html#gab6fc579f5d372dd13ed6ef863b369bd5">magma_zgbtrf_batched</a> (magma_int_t m, magma_int_t n, magma_int_t kl, magma_int_t ku, magmaDoubleComplex **dAB_array, magma_int_t lddab, magma_int_t **dipiv_array, magma_int_t *info_array, magma_int_t batchCount, <a class="el" href="structmagma__queue.html">magma_queue_t</a> queue)</td></tr>
<tr class="memdesc:gab6fc579f5d372dd13ed6ef863b369bd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">ZGBTRF computes an LU factorization of a COMPLEX m-by-n band matrix A using partial pivoting with row interchanges.  <br /></td></tr>
<tr class="separator:gab6fc579f5d372dd13ed6ef863b369bd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafdf9c7faa96f566e463dfc4bf7cca2de"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__getrf__batched.html#gafdf9c7faa96f566e463dfc4bf7cca2de">magma_zgbtrs_batched</a> (magma_trans_t transA, magma_int_t n, magma_int_t kl, magma_int_t ku, magma_int_t nrhs, magmaDoubleComplex **dA_array, magma_int_t ldda, magma_int_t **dipiv_array, magmaDoubleComplex **dB_array, magma_int_t lddb, magma_int_t *info_array, magma_int_t batchCount, <a class="el" href="structmagma__queue.html">magma_queue_t</a> queue)</td></tr>
<tr class="memdesc:gafdf9c7faa96f566e463dfc4bf7cca2de"><td class="mdescLeft">&#160;</td><td class="mdescRight">ZGBTRS solves a system of linear equations A * X = B, A**T * X = B, or A**H * X = B with a general band matrix A using the LU factorization computed by ZGBTRF.  <br /></td></tr>
<tr class="separator:gafdf9c7faa96f566e463dfc4bf7cca2de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabef89818dcb7947c49f4440b82b2f0b7"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__getrf__batched.html#gabef89818dcb7947c49f4440b82b2f0b7">magma_zgetrf_batched</a> (magma_int_t m, magma_int_t n, magmaDoubleComplex **dA_array, magma_int_t ldda, magma_int_t **ipiv_array, magma_int_t *info_array, magma_int_t batchCount, <a class="el" href="structmagma__queue.html">magma_queue_t</a> queue)</td></tr>
<tr class="memdesc:gabef89818dcb7947c49f4440b82b2f0b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">ZGETRF computes an LU factorization of a general M-by-N matrix A using partial pivoting with row interchanges.  <br /></td></tr>
<tr class="separator:gabef89818dcb7947c49f4440b82b2f0b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f5648a68cb0c5208acaa9f6f3f4befe"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__getrf__batched.html#ga8f5648a68cb0c5208acaa9f6f3f4befe">magma_zgetrf_recpanel_batched</a> (magma_int_t m, magma_int_t n, magma_int_t min_recpnb, magmaDoubleComplex **dA_array, magma_int_t ai, magma_int_t aj, magma_int_t ldda, magma_int_t **dipiv_array, magma_int_t **dpivinfo_array, magma_int_t *info_array, magma_int_t gbstep, magma_int_t batchCount, <a class="el" href="structmagma__queue.html">magma_queue_t</a> queue)</td></tr>
<tr class="memdesc:ga8f5648a68cb0c5208acaa9f6f3f4befe"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an internal routine that might have many assumption.  <br /></td></tr>
<tr class="separator:ga8f5648a68cb0c5208acaa9f6f3f4befe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f464db9d5e8060c94180a864d6688b1"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__getrf__batched.html#ga8f464db9d5e8060c94180a864d6688b1">magma_zgetrf_recpanel_native</a> (magma_int_t m, magma_int_t n, magma_int_t recnb, magmaDoubleComplex_ptr dA, magma_int_t ldda, magma_int_t *dipiv, magma_int_t *dipivinfo, magma_int_t *dinfo, magma_int_t gbstep, magma_event_t events[2], <a class="el" href="structmagma__queue.html">magma_queue_t</a> queue, <a class="el" href="structmagma__queue.html">magma_queue_t</a> update_queue)</td></tr>
<tr class="memdesc:ga8f464db9d5e8060c94180a864d6688b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an internal routine.  <br /></td></tr>
<tr class="separator:ga8f464db9d5e8060c94180a864d6688b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70a93ca906d74f3d1a865046ae26a5e7"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__getrf__batched.html#ga70a93ca906d74f3d1a865046ae26a5e7">magma_zgetrf_vbatched_max_nocheck_work</a> (magma_int_t *m, magma_int_t *n, magma_int_t max_m, magma_int_t max_n, magma_int_t max_minmn, magma_int_t max_mxn, magmaDoubleComplex **dA_array, magma_int_t *ldda, magma_int_t **dipiv_array, magma_int_t *info_array, void *work, magma_int_t *lwork, magma_int_t batchCount, <a class="el" href="structmagma__queue.html">magma_queue_t</a> queue)</td></tr>
<tr class="memdesc:ga70a93ca906d74f3d1a865046ae26a5e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">ZGETRF computes an LU factorization of a general M-by-N matrix A using partial pivoting with row interchanges.  <br /></td></tr>
<tr class="separator:ga70a93ca906d74f3d1a865046ae26a5e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga721a924bcd11aba71b77c8851d6d5ed6"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__getrf__batched.html#ga721a924bcd11aba71b77c8851d6d5ed6">magma_zgetrf_vbatched</a> (magma_int_t *m, magma_int_t *n, magmaDoubleComplex **dA_array, magma_int_t *ldda, magma_int_t **dipiv_array, magma_int_t *info_array, magma_int_t batchCount, <a class="el" href="structmagma__queue.html">magma_queue_t</a> queue)</td></tr>
<tr class="memdesc:ga721a924bcd11aba71b77c8851d6d5ed6"><td class="mdescLeft">&#160;</td><td class="mdescRight">ZGETRF computes an LU factorization of a general M-by-N matrix A using partial pivoting with row interchanges.  <br /></td></tr>
<tr class="separator:ga721a924bcd11aba71b77c8851d6d5ed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3247fe35270234d0b56eafd9fb1b4967"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__getrf__batched.html#ga3247fe35270234d0b56eafd9fb1b4967">magma_cgbsv_batched_fused_sm</a> (magma_int_t n, magma_int_t kl, magma_int_t ku, magma_int_t nrhs, magmaFloatComplex **dA_array, magma_int_t ldda, magma_int_t **ipiv_array, magmaFloatComplex **dB_array, magma_int_t lddb, magma_int_t *info_array, magma_int_t nthreads, magma_int_t ntcol, magma_int_t batchCount, <a class="el" href="structmagma__queue.html">magma_queue_t</a> queue)</td></tr>
<tr class="memdesc:ga3247fe35270234d0b56eafd9fb1b4967"><td class="mdescLeft">&#160;</td><td class="mdescRight">CGBSV computes the solution to a system of linear equations A * X = B, where A is a band matrix of order N with KL subdiagonals and KU superdiagonals, and X and B are N-by-NRHS matrices.  <br /></td></tr>
<tr class="separator:ga3247fe35270234d0b56eafd9fb1b4967"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga583108a75225b3136abc6431b151f901"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__getrf__batched.html#ga583108a75225b3136abc6431b151f901">magma_cgbtrf_batched_fused_sm</a> (magma_int_t m, magma_int_t n, magma_int_t kl, magma_int_t ku, magmaFloatComplex **dAB_array, magma_int_t lddab, magma_int_t **ipiv_array, magma_int_t *info_array, magma_int_t nthreads, magma_int_t ntcol, magma_int_t batchCount, <a class="el" href="structmagma__queue.html">magma_queue_t</a> queue)</td></tr>
<tr class="memdesc:ga583108a75225b3136abc6431b151f901"><td class="mdescLeft">&#160;</td><td class="mdescRight">CGBTRF computes an LU factorization of a COMPLEX m-by-n band matrix A using partial pivoting with row interchanges.  <br /></td></tr>
<tr class="separator:ga583108a75225b3136abc6431b151f901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaecd534b0b56150f0097139de783f9ff4"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__getrf__batched.html#gaecd534b0b56150f0097139de783f9ff4">magma_cgbtrf_batched_sliding_window_loopout</a> (magma_int_t m, magma_int_t n, magma_int_t kl, magma_int_t ku, magmaFloatComplex **dAB_array, magma_int_t lddab, magma_int_t **ipiv_array, magma_int_t *info_array, void *device_work, magma_int_t *lwork, magma_int_t batchCount, <a class="el" href="structmagma__queue.html">magma_queue_t</a> queue)</td></tr>
<tr class="memdesc:gaecd534b0b56150f0097139de783f9ff4"><td class="mdescLeft">&#160;</td><td class="mdescRight">CGBTRF computes an LU factorization of a COMPLEX m-by-n band matrix A using partial pivoting with row interchanges.  <br /></td></tr>
<tr class="separator:gaecd534b0b56150f0097139de783f9ff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25783d18215714f60c0035dd54f04178"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__getrf__batched.html#ga25783d18215714f60c0035dd54f04178">magma_cgbtrf_batched_sliding_window_loopin</a> (magma_int_t m, magma_int_t n, magma_int_t kl, magma_int_t ku, magmaFloatComplex **dAB_array, magma_int_t lddab, magma_int_t **ipiv_array, magma_int_t *info_array, magma_int_t batchCount, <a class="el" href="structmagma__queue.html">magma_queue_t</a> queue)</td></tr>
<tr class="memdesc:ga25783d18215714f60c0035dd54f04178"><td class="mdescLeft">&#160;</td><td class="mdescRight">CGBTRF computes an LU factorization of a COMPLEX m-by-n band matrix A using partial pivoting with row interchanges.  <br /></td></tr>
<tr class="separator:ga25783d18215714f60c0035dd54f04178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b8635f3d4af0e161cfc74efd709381f"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__getrf__batched.html#ga6b8635f3d4af0e161cfc74efd709381f">magma_cgetf2_nopiv_internal_batched</a> (magma_int_t m, magma_int_t n, magmaFloatComplex **dA_array, magma_int_t ai, magma_int_t aj, magma_int_t ldda, magma_int_t *info_array, magma_int_t gbstep, magma_int_t batchCount, <a class="el" href="structmagma__queue.html">magma_queue_t</a> queue)</td></tr>
<tr class="memdesc:ga6b8635f3d4af0e161cfc74efd709381f"><td class="mdescLeft">&#160;</td><td class="mdescRight">cgetf2_nopiv computes the non-pivoting LU factorization of an M-by-N matrix A.  <br /></td></tr>
<tr class="separator:ga6b8635f3d4af0e161cfc74efd709381f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga056162626c59f65150c9b80a9e968f5a"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__getrf__batched.html#ga056162626c59f65150c9b80a9e968f5a">magma_cgetrf_batched_smallsq_noshfl</a> (magma_int_t n, magmaFloatComplex **dA_array, magma_int_t ldda, magma_int_t **ipiv_array, magma_int_t *info_array, magma_int_t batchCount, <a class="el" href="structmagma__queue.html">magma_queue_t</a> queue)</td></tr>
<tr class="memdesc:ga056162626c59f65150c9b80a9e968f5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">cgetrf_batched_smallsq_noshfl computes the LU factorization of a square N-by-N matrix A using partial pivoting with row interchanges.  <br /></td></tr>
<tr class="separator:ga056162626c59f65150c9b80a9e968f5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab01b3805ed46bf82ce289b4515e04c3d"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__getrf__batched.html#gab01b3805ed46bf82ce289b4515e04c3d">magma_dgbsv_batched_fused_sm</a> (magma_int_t n, magma_int_t kl, magma_int_t ku, magma_int_t nrhs, double **dA_array, magma_int_t ldda, magma_int_t **ipiv_array, double **dB_array, magma_int_t lddb, magma_int_t *info_array, magma_int_t nthreads, magma_int_t ntcol, magma_int_t batchCount, <a class="el" href="structmagma__queue.html">magma_queue_t</a> queue)</td></tr>
<tr class="memdesc:gab01b3805ed46bf82ce289b4515e04c3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">DGBSV computes the solution to a system of linear equations A * X = B, where A is a band matrix of order N with KL subdiagonals and KU superdiagonals, and X and B are N-by-NRHS matrices.  <br /></td></tr>
<tr class="separator:gab01b3805ed46bf82ce289b4515e04c3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa66ba9e089111eb1ade897064e59a105"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__getrf__batched.html#gaa66ba9e089111eb1ade897064e59a105">magma_dgbtrf_batched_fused_sm</a> (magma_int_t m, magma_int_t n, magma_int_t kl, magma_int_t ku, double **dAB_array, magma_int_t lddab, magma_int_t **ipiv_array, magma_int_t *info_array, magma_int_t nthreads, magma_int_t ntcol, magma_int_t batchCount, <a class="el" href="structmagma__queue.html">magma_queue_t</a> queue)</td></tr>
<tr class="memdesc:gaa66ba9e089111eb1ade897064e59a105"><td class="mdescLeft">&#160;</td><td class="mdescRight">DGBTRF computes an LU factorization of a COMPLEX m-by-n band matrix A using partial pivoting with row interchanges.  <br /></td></tr>
<tr class="separator:gaa66ba9e089111eb1ade897064e59a105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade427e6a3fa4401d1eb5deccfdaad0bf"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__getrf__batched.html#gade427e6a3fa4401d1eb5deccfdaad0bf">magma_dgbtrf_batched_sliding_window_loopout</a> (magma_int_t m, magma_int_t n, magma_int_t kl, magma_int_t ku, double **dAB_array, magma_int_t lddab, magma_int_t **ipiv_array, magma_int_t *info_array, void *device_work, magma_int_t *lwork, magma_int_t batchCount, <a class="el" href="structmagma__queue.html">magma_queue_t</a> queue)</td></tr>
<tr class="memdesc:gade427e6a3fa4401d1eb5deccfdaad0bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">DGBTRF computes an LU factorization of a COMPLEX m-by-n band matrix A using partial pivoting with row interchanges.  <br /></td></tr>
<tr class="separator:gade427e6a3fa4401d1eb5deccfdaad0bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6f8c98a9c177fea9622e1e14b58754a"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__getrf__batched.html#gaa6f8c98a9c177fea9622e1e14b58754a">magma_dgbtrf_batched_sliding_window_loopin</a> (magma_int_t m, magma_int_t n, magma_int_t kl, magma_int_t ku, double **dAB_array, magma_int_t lddab, magma_int_t **ipiv_array, magma_int_t *info_array, magma_int_t batchCount, <a class="el" href="structmagma__queue.html">magma_queue_t</a> queue)</td></tr>
<tr class="memdesc:gaa6f8c98a9c177fea9622e1e14b58754a"><td class="mdescLeft">&#160;</td><td class="mdescRight">DGBTRF computes an LU factorization of a COMPLEX m-by-n band matrix A using partial pivoting with row interchanges.  <br /></td></tr>
<tr class="separator:gaa6f8c98a9c177fea9622e1e14b58754a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8d797324a846e8a356b7a9dc2d5fa99"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__getrf__batched.html#gab8d797324a846e8a356b7a9dc2d5fa99">magma_dgetf2_nopiv_internal_batched</a> (magma_int_t m, magma_int_t n, double **dA_array, magma_int_t ai, magma_int_t aj, magma_int_t ldda, magma_int_t *info_array, magma_int_t gbstep, magma_int_t batchCount, <a class="el" href="structmagma__queue.html">magma_queue_t</a> queue)</td></tr>
<tr class="memdesc:gab8d797324a846e8a356b7a9dc2d5fa99"><td class="mdescLeft">&#160;</td><td class="mdescRight">dgetf2_nopiv computes the non-pivoting LU factorization of an M-by-N matrix A.  <br /></td></tr>
<tr class="separator:gab8d797324a846e8a356b7a9dc2d5fa99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29efea15394a7e827c7ebc3f8e9a33a6"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__getrf__batched.html#ga29efea15394a7e827c7ebc3f8e9a33a6">magma_dgetrf_batched_smallsq_noshfl</a> (magma_int_t n, double **dA_array, magma_int_t ldda, magma_int_t **ipiv_array, magma_int_t *info_array, magma_int_t batchCount, <a class="el" href="structmagma__queue.html">magma_queue_t</a> queue)</td></tr>
<tr class="memdesc:ga29efea15394a7e827c7ebc3f8e9a33a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">dgetrf_batched_smallsq_noshfl computes the LU factorization of a square N-by-N matrix A using partial pivoting with row interchanges.  <br /></td></tr>
<tr class="separator:ga29efea15394a7e827c7ebc3f8e9a33a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed9b8e9d701d4472c326c14d273c08fb"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__getrf__batched.html#gaed9b8e9d701d4472c326c14d273c08fb">magma_sgbsv_batched_fused_sm</a> (magma_int_t n, magma_int_t kl, magma_int_t ku, magma_int_t nrhs, float **dA_array, magma_int_t ldda, magma_int_t **ipiv_array, float **dB_array, magma_int_t lddb, magma_int_t *info_array, magma_int_t nthreads, magma_int_t ntcol, magma_int_t batchCount, <a class="el" href="structmagma__queue.html">magma_queue_t</a> queue)</td></tr>
<tr class="memdesc:gaed9b8e9d701d4472c326c14d273c08fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">SGBSV computes the solution to a system of linear equations A * X = B, where A is a band matrix of order N with KL subdiagonals and KU superdiagonals, and X and B are N-by-NRHS matrices.  <br /></td></tr>
<tr class="separator:gaed9b8e9d701d4472c326c14d273c08fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55fdce37833793cac7968482d25a27a6"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__getrf__batched.html#ga55fdce37833793cac7968482d25a27a6">magma_sgbtrf_batched_fused_sm</a> (magma_int_t m, magma_int_t n, magma_int_t kl, magma_int_t ku, float **dAB_array, magma_int_t lddab, magma_int_t **ipiv_array, magma_int_t *info_array, magma_int_t nthreads, magma_int_t ntcol, magma_int_t batchCount, <a class="el" href="structmagma__queue.html">magma_queue_t</a> queue)</td></tr>
<tr class="memdesc:ga55fdce37833793cac7968482d25a27a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">SGBTRF computes an LU factorization of a COMPLEX m-by-n band matrix A using partial pivoting with row interchanges.  <br /></td></tr>
<tr class="separator:ga55fdce37833793cac7968482d25a27a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadba9fd8a2d613a921353a0595b764113"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__getrf__batched.html#gadba9fd8a2d613a921353a0595b764113">magma_sgbtrf_batched_sliding_window_loopout</a> (magma_int_t m, magma_int_t n, magma_int_t kl, magma_int_t ku, float **dAB_array, magma_int_t lddab, magma_int_t **ipiv_array, magma_int_t *info_array, void *device_work, magma_int_t *lwork, magma_int_t batchCount, <a class="el" href="structmagma__queue.html">magma_queue_t</a> queue)</td></tr>
<tr class="memdesc:gadba9fd8a2d613a921353a0595b764113"><td class="mdescLeft">&#160;</td><td class="mdescRight">SGBTRF computes an LU factorization of a COMPLEX m-by-n band matrix A using partial pivoting with row interchanges.  <br /></td></tr>
<tr class="separator:gadba9fd8a2d613a921353a0595b764113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e40200eaec9b1f83606af85309c54aa"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__getrf__batched.html#ga8e40200eaec9b1f83606af85309c54aa">magma_sgbtrf_batched_sliding_window_loopin</a> (magma_int_t m, magma_int_t n, magma_int_t kl, magma_int_t ku, float **dAB_array, magma_int_t lddab, magma_int_t **ipiv_array, magma_int_t *info_array, magma_int_t batchCount, <a class="el" href="structmagma__queue.html">magma_queue_t</a> queue)</td></tr>
<tr class="memdesc:ga8e40200eaec9b1f83606af85309c54aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">SGBTRF computes an LU factorization of a COMPLEX m-by-n band matrix A using partial pivoting with row interchanges.  <br /></td></tr>
<tr class="separator:ga8e40200eaec9b1f83606af85309c54aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67737def4165c9a35af9ff1eeef4c529"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__getrf__batched.html#ga67737def4165c9a35af9ff1eeef4c529">magma_sgetf2_nopiv_internal_batched</a> (magma_int_t m, magma_int_t n, float **dA_array, magma_int_t ai, magma_int_t aj, magma_int_t ldda, magma_int_t *info_array, magma_int_t gbstep, magma_int_t batchCount, <a class="el" href="structmagma__queue.html">magma_queue_t</a> queue)</td></tr>
<tr class="memdesc:ga67737def4165c9a35af9ff1eeef4c529"><td class="mdescLeft">&#160;</td><td class="mdescRight">sgetf2_nopiv computes the non-pivoting LU factorization of an M-by-N matrix A.  <br /></td></tr>
<tr class="separator:ga67737def4165c9a35af9ff1eeef4c529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga532da9fac258f0baaba28a38f19f7bdf"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__getrf__batched.html#ga532da9fac258f0baaba28a38f19f7bdf">magma_sgetrf_batched_smallsq_noshfl</a> (magma_int_t n, float **dA_array, magma_int_t ldda, magma_int_t **ipiv_array, magma_int_t *info_array, magma_int_t batchCount, <a class="el" href="structmagma__queue.html">magma_queue_t</a> queue)</td></tr>
<tr class="memdesc:ga532da9fac258f0baaba28a38f19f7bdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">sgetrf_batched_smallsq_noshfl computes the LU factorization of a square N-by-N matrix A using partial pivoting with row interchanges.  <br /></td></tr>
<tr class="separator:ga532da9fac258f0baaba28a38f19f7bdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef70b4926971c3b3e486ad28ab57cfc7"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__getrf__batched.html#gaef70b4926971c3b3e486ad28ab57cfc7">magma_zgbsv_batched_fused_sm</a> (magma_int_t n, magma_int_t kl, magma_int_t ku, magma_int_t nrhs, magmaDoubleComplex **dA_array, magma_int_t ldda, magma_int_t **ipiv_array, magmaDoubleComplex **dB_array, magma_int_t lddb, magma_int_t *info_array, magma_int_t nthreads, magma_int_t ntcol, magma_int_t batchCount, <a class="el" href="structmagma__queue.html">magma_queue_t</a> queue)</td></tr>
<tr class="memdesc:gaef70b4926971c3b3e486ad28ab57cfc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">ZGBSV computes the solution to a system of linear equations A * X = B, where A is a band matrix of order N with KL subdiagonals and KU superdiagonals, and X and B are N-by-NRHS matrices.  <br /></td></tr>
<tr class="separator:gaef70b4926971c3b3e486ad28ab57cfc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga332dcd218102adcba76d8ec9f70f5e23"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__getrf__batched.html#ga332dcd218102adcba76d8ec9f70f5e23">magma_zgbtrf_batched_fused_sm</a> (magma_int_t m, magma_int_t n, magma_int_t kl, magma_int_t ku, magmaDoubleComplex **dAB_array, magma_int_t lddab, magma_int_t **ipiv_array, magma_int_t *info_array, magma_int_t nthreads, magma_int_t ntcol, magma_int_t batchCount, <a class="el" href="structmagma__queue.html">magma_queue_t</a> queue)</td></tr>
<tr class="memdesc:ga332dcd218102adcba76d8ec9f70f5e23"><td class="mdescLeft">&#160;</td><td class="mdescRight">ZGBTRF computes an LU factorization of a COMPLEX m-by-n band matrix A using partial pivoting with row interchanges.  <br /></td></tr>
<tr class="separator:ga332dcd218102adcba76d8ec9f70f5e23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab43e864ff87ac5581f40a4647f64026c"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__getrf__batched.html#gab43e864ff87ac5581f40a4647f64026c">magma_zgbtrf_batched_sliding_window_loopout</a> (magma_int_t m, magma_int_t n, magma_int_t kl, magma_int_t ku, magmaDoubleComplex **dAB_array, magma_int_t lddab, magma_int_t **ipiv_array, magma_int_t *info_array, void *device_work, magma_int_t *lwork, magma_int_t batchCount, <a class="el" href="structmagma__queue.html">magma_queue_t</a> queue)</td></tr>
<tr class="memdesc:gab43e864ff87ac5581f40a4647f64026c"><td class="mdescLeft">&#160;</td><td class="mdescRight">ZGBTRF computes an LU factorization of a COMPLEX m-by-n band matrix A using partial pivoting with row interchanges.  <br /></td></tr>
<tr class="separator:gab43e864ff87ac5581f40a4647f64026c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76ea175718812162c68fa57b6a3f6ffd"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__getrf__batched.html#ga76ea175718812162c68fa57b6a3f6ffd">magma_zgbtrf_batched_sliding_window_loopin</a> (magma_int_t m, magma_int_t n, magma_int_t kl, magma_int_t ku, magmaDoubleComplex **dAB_array, magma_int_t lddab, magma_int_t **ipiv_array, magma_int_t *info_array, magma_int_t batchCount, <a class="el" href="structmagma__queue.html">magma_queue_t</a> queue)</td></tr>
<tr class="memdesc:ga76ea175718812162c68fa57b6a3f6ffd"><td class="mdescLeft">&#160;</td><td class="mdescRight">ZGBTRF computes an LU factorization of a COMPLEX m-by-n band matrix A using partial pivoting with row interchanges.  <br /></td></tr>
<tr class="separator:ga76ea175718812162c68fa57b6a3f6ffd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga351030f7d65ed12639f7601eefb62254"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__getrf__batched.html#ga351030f7d65ed12639f7601eefb62254">magma_zgetf2_nopiv_internal_batched</a> (magma_int_t m, magma_int_t n, magmaDoubleComplex **dA_array, magma_int_t ai, magma_int_t aj, magma_int_t ldda, magma_int_t *info_array, magma_int_t gbstep, magma_int_t batchCount, <a class="el" href="structmagma__queue.html">magma_queue_t</a> queue)</td></tr>
<tr class="memdesc:ga351030f7d65ed12639f7601eefb62254"><td class="mdescLeft">&#160;</td><td class="mdescRight">zgetf2_nopiv computes the non-pivoting LU factorization of an M-by-N matrix A.  <br /></td></tr>
<tr class="separator:ga351030f7d65ed12639f7601eefb62254"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2a92e4171bbb5128c25c767df760011"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__getrf__batched.html#gab2a92e4171bbb5128c25c767df760011">magma_zgetrf_batched_smallsq_noshfl</a> (magma_int_t n, magmaDoubleComplex **dA_array, magma_int_t ldda, magma_int_t **ipiv_array, magma_int_t *info_array, magma_int_t batchCount, <a class="el" href="structmagma__queue.html">magma_queue_t</a> queue)</td></tr>
<tr class="memdesc:gab2a92e4171bbb5128c25c767df760011"><td class="mdescLeft">&#160;</td><td class="mdescRight">zgetrf_batched_smallsq_noshfl computes the LU factorization of a square N-by-N matrix A using partial pivoting with row interchanges.  <br /></td></tr>
<tr class="separator:gab2a92e4171bbb5128c25c767df760011"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga850c86b299cb8d37d201299ec739aae9" name="ga850c86b299cb8d37d201299ec739aae9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga850c86b299cb8d37d201299ec739aae9">&#9670;&#160;</a></span>magma_cgbsv_batched_work()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_cgbsv_batched_work </td>
          <td>(</td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>kl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ku</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>nrhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex **&#160;</td>
          <td class="paramname"><em>dA_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t **&#160;</td>
          <td class="paramname"><em>dipiv_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex **&#160;</td>
          <td class="paramname"><em>dB_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lddb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>device_work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>batchCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmagma__queue.html">magma_queue_t</a>&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>CGBSV computes the solution to a system of linear equations A * X = B, where A is a band matrix of order N with KL subdiagonals and KU superdiagonals, and X and B are N-by-NRHS matrices. </p>
<p>The LU decomposition with partial pivoting and row interchanges is used to factor A as A = L * U, where L is a product of permutation and unit lower triangular matrices with KL subdiagonals, and U is upper triangular with KL+KU superdiagonals. The factored form of A is then used to solve the system of equations A * X = B.</p>
<p>This is the batched version of the routine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>INTEGER The order of the matrix A. n &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kl</td><td>INTEGER The number of subdiagonals within the band of A. KL &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ku</td><td>INTEGER The number of superdiagonals within the band of A. KL &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nrhs</td><td>INTEGER The number of right hand sides, i.e., the number of columns of the matrix B. NRHS &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dA_array</td><td>Array of pointers, dimension (batchCount). Each contains the details of the LU factorization of the band matrix A, as computed by CGBTRF. U is stored as an upper triangular band matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and the multipliers used during the factorization are stored in rows KL+KU+2 to 2*KL+KU+1.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldda</td><td>INTEGER The leading dimension of each array A. LDDA &gt;= (2*KL+KU+1).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dipiv_array</td><td>Array of pointers, dimension (batchCount), for corresponding matrices. Each is an INTEGER array, dimension (min(M,N)) The pivot indices; for 1 &lt;= i &lt;= min(M,N), row i of the matrix was interchanged with row IPIV(i).</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dB_array</td><td>Array of pointers, dimension (batchCount). Each is a COMPLEX array, dimension (LDB,NRHS) On entry, the right hand side matrix B. On exit, the solution matrix X.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lddb</td><td>INTEGER The leading dimension of each array B. LDDB &gt;= max(1, N).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info_array</td><td>Array of INTEGERs, dimension (batchCount), for corresponding matrices.<ul>
<li>= 0: successful exit</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value or another error occured, such as memory allocation failed. &gt; 0: if INFO = i, U(i,i) is exactly zero. The factorization has been completed, but the factor U is exactly singular, and the solution has not been computed.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">device_work</td><td>Workspace, allocated on device memory.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lwork</td><td>INTEGER pointer The size of the workspace (device_work) in bytes<ul>
<li>lwork[0] &lt; 0: a workspace query is assumed, the routine calculates the required amount of workspace and returns it in lwork. The workspace is not referenced, and no computation is performed.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>lwork[0] &gt;= 0: the routine assumes that the user has provided a workspace with the size in lwork.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">batchCount</td><td>INTEGER The number of matrices to operate on.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>magma_queue_t Queue to execute in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8022b4ce3bacbb81faa5db0f22c7f6d9" name="ga8022b4ce3bacbb81faa5db0f22c7f6d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8022b4ce3bacbb81faa5db0f22c7f6d9">&#9670;&#160;</a></span>magma_cgbsv_batched()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_cgbsv_batched </td>
          <td>(</td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>kl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ku</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>nrhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex **&#160;</td>
          <td class="paramname"><em>dA_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t **&#160;</td>
          <td class="paramname"><em>dipiv_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex **&#160;</td>
          <td class="paramname"><em>dB_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lddb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>batchCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmagma__queue.html">magma_queue_t</a>&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>CGBSV computes the solution to a system of linear equations A * X = B, where A is a band matrix of order N with KL subdiagonals and KU superdiagonals, and X and B are N-by-NRHS matrices. </p>
<p>The LU decomposition with partial pivoting and row interchanges is used to factor A as A = L * U, where L is a product of permutation and unit lower triangular matrices with KL subdiagonals, and U is upper triangular with KL+KU superdiagonals. The factored form of A is then used to solve the system of equations A * X = B.</p>
<p>This is the batched version of the routine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>INTEGER The order of the matrix A. n &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kl</td><td>INTEGER The number of subdiagonals within the band of A. KL &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ku</td><td>INTEGER The number of superdiagonals within the band of A. KL &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nrhs</td><td>INTEGER The number of right hand sides, i.e., the number of columns of the matrix B. NRHS &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dA_array</td><td>Array of pointers, dimension (batchCount). Each contains the details of the LU factorization of the band matrix A, as computed by CGBTRF. U is stored as an upper triangular band matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and the multipliers used during the factorization are stored in rows KL+KU+2 to 2*KL+KU+1.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldda</td><td>INTEGER The leading dimension of each array A. LDDA &gt;= (2*KL+KU+1).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dipiv_array</td><td>Array of pointers, dimension (batchCount), for corresponding matrices. Each is an INTEGER array, dimension (min(M,N)) The pivot indices; for 1 &lt;= i &lt;= min(M,N), row i of the matrix was interchanged with row IPIV(i).</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dB_array</td><td>Array of pointers, dimension (batchCount). Each is a COMPLEX array, dimension (LDB,NRHS) On entry, the right hand side matrix B. On exit, the solution matrix X.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lddb</td><td>INTEGER The leading dimension of each array B. LDDB &gt;= max(1, N).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info_array</td><td>Array of INTEGERs, dimension (batchCount), for corresponding matrices.<ul>
<li>= 0: successful exit</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value or another error occured, such as memory allocation failed.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">batchCount</td><td>INTEGER The number of matrices to operate on.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>magma_queue_t Queue to execute in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6c61b55f5b33597f7daf13081ffe4e78" name="ga6c61b55f5b33597f7daf13081ffe4e78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6c61b55f5b33597f7daf13081ffe4e78">&#9670;&#160;</a></span>magma_cgbtrf_batched_work()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_cgbtrf_batched_work </td>
          <td>(</td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>kl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ku</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex **&#160;</td>
          <td class="paramname"><em>dAB_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lddab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t **&#160;</td>
          <td class="paramname"><em>dipiv_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>device_work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>batchCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmagma__queue.html">magma_queue_t</a>&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>CGBTRF computes an LU factorization of a complex m-by-n band matrix AB using partial pivoting with row interchanges. </p>
<p>This is a batched version that factors <code>batchCount</code> M-by-N matrices in parallel. dAB, dipiv, and info become arrays with one entry per matrix.</p>
<p>The band storage scheme is illustrated by the following example, when M = N = 6, KL = 2, KU = 1:</p>
<p>On entry: On exit: </p><pre class="fragment">    *    *    +    +    +       *    *    *   u14  u25  u36
    *    +    +    +    +       *    *   u13  u24  u35  u46
   a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56
</pre><p> a11 a22 a33 a44 a55 a66 u11 u22 u33 u44 u55 u66 a21 a32 a43 a54 a65 * m21 m32 m43 m54 m65 * a31 a42 a53 a64 * * m31 m42 m53 m64 * *</p>
<p>Note that this behavior is a little different from the standard LAPACK routine. Array elements marked * are not read by the routine, but may be zeroed out after completion. Elements marked + need not be set on entry, but are required by the routine to store elements of U because of fill-in resulting from the row interchanges.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>INTEGER The number of rows of each matrix A. M &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>INTEGER The number of columns of each matrix A. N &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kl</td><td>INTEGER The number of subdiagonals within the band of A. KL &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ku</td><td>INTEGER The number of superdiagonals within the band of A. KL &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dAB_array</td><td>Array of pointers, dimension (batchCount). Each is a COMPLEX array on the GPU, dimension (LDAB,N) On entry, the matrix A in band storage, in rows KL+1 to 2*KL+KU+1; rows 1 to KL of the array need not be set. The j-th column of A is stored in the j-th column of the array AB as follows: AB(kl+ku+1+i-j,j) = A(i,j) for max(1,j-ku)&lt;=i&lt;=min(m,j+kl)</td></tr>
  </table>
  </dd>
</dl>
<p>On exit, details of the factorization: U is stored as an upper triangular band matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and the multipliers used during the factorization are stored in rows KL+KU+2 to 2*KL+KU+1. See above for details about the band storage.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lddab</td><td>INTEGER The leading dimension of each array AB. LDDAB &gt;= (2*KL+KU+1).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dipiv_array</td><td>Array of pointers, dimension (batchCount), for corresponding matrices. Each is an INTEGER array, dimension (min(M,N)) The pivot indices; for 1 &lt;= i &lt;= min(M,N), row i of the matrix was interchanged with row IPIV(i).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info_array</td><td>Array of INTEGERs, dimension (batchCount), for corresponding matrices.<ul>
<li>= 0: successful exit</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value or another error occured, such as memory allocation failed.</li>
<li>&gt; 0: if INFO = i, U(i,i) is exactly zero. The factorization has been completed, but the factor U is exactly singular, and division by zero will occur if it is used to solve a system of equations.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">device_work</td><td>Workspace, allocated on device memory</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lwork</td><td>INTEGER pointer The size of the workspace (device_work) in bytes<ul>
<li>lwork[0] &lt; 0: a workspace query is assumed, the routine calculates the required amount of workspace and returns it in lwork. The workspace is not referenced, and no factorization is performed.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>lwork[0] &gt;= 0: the routine assumes that the user has provided a workspace with the size in lwork.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">batchCount</td><td>INTEGER The number of matrices to operate on.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>magma_queue_t Queue to execute in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga53418c8cc29eddbb54f9fb52e6f66e88" name="ga53418c8cc29eddbb54f9fb52e6f66e88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga53418c8cc29eddbb54f9fb52e6f66e88">&#9670;&#160;</a></span>magma_cgbtrf_batched()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_cgbtrf_batched </td>
          <td>(</td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>kl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ku</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex **&#160;</td>
          <td class="paramname"><em>dAB_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lddab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t **&#160;</td>
          <td class="paramname"><em>dipiv_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>batchCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmagma__queue.html">magma_queue_t</a>&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>CGBTRF computes an LU factorization of a COMPLEX m-by-n band matrix A using partial pivoting with row interchanges. </p>
<p>This is the batched version of the algorithm, which performs the factorization on a batch of matrices with the same size and lower/upper bandwidths.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>INTEGER The number of rows of the matrix A. M &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>INTEGER The number of columns of the matrix A. N &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">KL</td><td>INTEGER The number of subdiagonals within the band of A. KL &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">KU</td><td>INTEGER The number of superdiagonals within the band of A. KU &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dAB_array</td><td>Array of pointers, dimension (batchCount). Each is a COMPLEX array, dimension (LDDAB,N) On entry, the matrix AB in band storage, in rows KL+1 to 2*KL+KU+1; rows 1 to KL of the array need not be set. The j-th column of A is stored in the j-th column of the array AB as follows: AB(kl+ku+1+i-j,j) = A(i,j) for max(1,j-ku)&lt;=i&lt;=min(m,j+kl)</td></tr>
  </table>
  </dd>
</dl>
<p>On exit, details of the factorization: U is stored as an upper triangular band matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and the multipliers used during the factorization are stored in rows KL+KU+2 to 2*KL+KU+1. See below for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">LDDAB</td><td>INTEGER The leading dimension of the array AB. LDAB &gt;= 2*KL+KU+1.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dIPIV_array</td><td>Array of pointers, dimension (batchCount). Each is an INTEGER array, dimension (min(M,N)) The pivot indices; for 1 &lt;= i &lt;= min(M,N), row i of the matrix was interchanged with row IPIV(i).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dINFO_array</td><td>INTEGER array, dimension (batchCount) Each is the INFO output for a given matrix = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value &gt; 0: if INFO = +i, U(i,i) is exactly zero. The factorization has been completed, but the factor U is exactly singular, and division by zero will occur if it is used to solve a system of equations.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">batchCount</td><td>INTEGER The number of matrices to operate on.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>magma_queue_t Queue to execute in.</td></tr>
  </table>
  </dd>
</dl>
<h1><a class="anchor" id="autotoc_md24"></a>
Further Details</h1>
<p>The band storage scheme is illustrated by the following example, when M = N = 6, KL = 2, KU = 1:</p>
<p>On entry: On exit: </p><pre class="fragment">     *    *    +    +    +       *    *    *   u14  u25  u36
     *    +    +    +    +       *    *   u13  u24  u35  u46
    a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56
</pre><p> a11 a22 a33 a44 a55 a66 u11 u22 u33 u44 u55 u66 a21 a32 a43 a54 a65 * m21 m32 m43 m54 m65 * a31 a42 a53 a64 * * m31 m42 m53 m64 * *</p>
<p>Array elements marked * are not used by the routine; elements marked</p><ul>
<li>need not be set on entry, but are required by the routine to store elements of U because of fill-in resulting from the row interchanges. </li>
</ul>

</div>
</div>
<a id="gaed2b56b3482b185a8fb6a4ad52461aa9" name="gaed2b56b3482b185a8fb6a4ad52461aa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaed2b56b3482b185a8fb6a4ad52461aa9">&#9670;&#160;</a></span>magma_cgbtrs_batched()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_cgbtrs_batched </td>
          <td>(</td>
          <td class="paramtype">magma_trans_t&#160;</td>
          <td class="paramname"><em>transA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>kl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ku</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>nrhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex **&#160;</td>
          <td class="paramname"><em>dA_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t **&#160;</td>
          <td class="paramname"><em>dipiv_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex **&#160;</td>
          <td class="paramname"><em>dB_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lddb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>batchCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmagma__queue.html">magma_queue_t</a>&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>CGBTRS solves a system of linear equations A * X = B, A**T * X = B, or A**H * X = B with a general band matrix A using the LU factorization computed by CGBTRF. </p>
<p>This is the batched version of the routine. Currently, only (A * X = B) is supported (no-trans only)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">transA</td><td>magma_trans_t Specifies the form of the system of equations. Currently, only MagnaNoTrans is supported (A*X = B)</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>INTEGER The order of the matrix A. n &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kl</td><td>INTEGER The number of subdiagonals within the band of A. KL &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ku</td><td>INTEGER The number of superdiagonals within the band of A. KL &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nrhs</td><td>INTEGER The number of right hand sides, i.e., the number of columns of the matrix B. NRHS &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dA_array</td><td>Array of pointers, dimension (batchCount). Each contains the details of the LU factorization of the band matrix A, as computed by CGBTRF. U is stored as an upper triangular band matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and the multipliers used during the factorization are stored in rows KL+KU+2 to 2*KL+KU+1.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldda</td><td>INTEGER The leading dimension of each array A. LDDA &gt;= (2*KL+KU+1).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dipiv_array</td><td>Array of pointers, dimension (batchCount), for corresponding matrices. Each is an INTEGER array, dimension (min(M,N)) The pivot indices; for 1 &lt;= i &lt;= min(M,N), row i of the matrix was interchanged with row IPIV(i).</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dB_array</td><td>Array of pointers, dimension (batchCount). Each is a COMPLEX array, dimension (LDB,NRHS) On entry, the right hand side matrix B. On exit, the solution matrix X.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lddb</td><td>INTEGER The leading dimension of each array B. LDDB &gt;= max(1, N).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info_array</td><td>Array of INTEGERs, dimension (batchCount), for corresponding matrices.<ul>
<li>= 0: successful exit</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value or another error occured, such as memory allocation failed.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">batchCount</td><td>INTEGER The number of matrices to operate on.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>magma_queue_t Queue to execute in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac5d0dfc5179e4ff7dd34971c885afb79" name="gac5d0dfc5179e4ff7dd34971c885afb79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac5d0dfc5179e4ff7dd34971c885afb79">&#9670;&#160;</a></span>magma_cgetrf_batched()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_cgetrf_batched </td>
          <td>(</td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex **&#160;</td>
          <td class="paramname"><em>dA_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t **&#160;</td>
          <td class="paramname"><em>ipiv_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>batchCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmagma__queue.html">magma_queue_t</a>&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>CGETRF computes an LU factorization of a general M-by-N matrix A using partial pivoting with row interchanges. </p>
<p>The factorization has the form A = P * L * U where P is a permutation matrix, L is lower triangular with unit diagonal elements (lower trapezoidal if m &gt; n), and U is upper triangular (upper trapezoidal if m &lt; n).</p>
<p>This is the right-looking Level 3 BLAS version of the algorithm.</p>
<p>This is a batched version that factors batchCount M-by-N matrices in parallel. dA, ipiv, and info become arrays with one entry per matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>INTEGER The number of rows of each matrix A. M &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>INTEGER The number of columns of each matrix A. N &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dA_array</td><td>Array of pointers, dimension (batchCount). Each is a COMPLEX array on the GPU, dimension (LDDA,N). On entry, each pointer is an M-by-N matrix to be factored. On exit, the factors L and U from the factorization A = P*L*U; the unit diagonal elements of L are not stored.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldda</td><td>INTEGER The leading dimension of each array A. LDDA &gt;= max(1,M).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ipiv_array</td><td>Array of pointers, dimension (batchCount), for corresponding matrices. Each is an INTEGER array, dimension (min(M,N)) The pivot indices; for 1 &lt;= i &lt;= min(M,N), row i of the matrix was interchanged with row IPIV(i).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info_array</td><td>Array of INTEGERs, dimension (batchCount), for corresponding matrices.<ul>
<li>= 0: successful exit</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value or another error occured, such as memory allocation failed.</li>
<li>&gt; 0: if INFO = i, U(i,i) is exactly zero. The factorization has been completed, but the factor U is exactly singular, and division by zero will occur if it is used to solve a system of equations.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">batchCount</td><td>INTEGER The number of matrices to operate on.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>magma_queue_t Queue to execute in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga188b8b2cebe437eb093f504dd7ce69f3" name="ga188b8b2cebe437eb093f504dd7ce69f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga188b8b2cebe437eb093f504dd7ce69f3">&#9670;&#160;</a></span>magma_cgetrf_recpanel_batched()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_cgetrf_recpanel_batched </td>
          <td>(</td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>min_recpnb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex **&#160;</td>
          <td class="paramname"><em>dA_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ai</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>aj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t **&#160;</td>
          <td class="paramname"><em>dipiv_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t **&#160;</td>
          <td class="paramname"><em>dpivinfo_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>gbstep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>batchCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmagma__queue.html">magma_queue_t</a>&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an internal routine that might have many assumption. </p>
<p>Documentation is not fully completed</p>
<p>CGETRF_PANEL computes an LU factorization of a general M-by-N matrix A using partial pivoting with row interchanges.</p>
<p>The factorization has the form A = P * L * U where P is a permutation matrix, L is lower triangular with unit diagonal elements (lower trapezoidal if m &gt; n), and U is upper triangular (upper trapezoidal if m &lt; n).</p>
<p>This is the right-looking Level 3 BLAS version of the algorithm.</p>
<p>This is a batched version that factors batchCount M-by-N matrices in parallel. dA, ipiv, and info become arrays with one entry per matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>INTEGER The number of rows of each matrix A. M &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>INTEGER The number of columns of each matrix A. N &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">min_recpnb</td><td>INTEGER. Internal use. The recursive nb</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dA_array</td><td>Array of pointers, dimension (batchCount). Each is a COMPLEX array on the GPU, dimension (LDDA,N). On entry, each pointer is an M-by-N matrix to be factored. On exit, the factors L and U from the factorization A = P*L*U; the unit diagonal elements of L are not stored.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ai</td><td>INTEGER Row offset for A.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aj</td><td>INTEGER Column offset for A.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldda</td><td>INTEGER The leading dimension of each array A. LDDA &gt;= max(1,M).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dipiv_array</td><td>Array of pointers, dimension (batchCount), for corresponding matrices. Each is an INTEGER array, dimension (min(M,N)) The pivot indices; for 1 &lt;= i &lt;= min(M,N), row i of the matrix was interchanged with row IPIV(i).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dpivinfo_array</td><td>Array of pointers, dimension (batchCount), for internal use.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info_array</td><td>Array of INTEGERs, dimension (batchCount), for corresponding matrices.<ul>
<li>= 0: successful exit</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value or another error occured, such as memory allocation failed.</li>
<li>&gt; 0: if INFO = i, U(i,i) is exactly zero. The factorization has been completed, but the factor U is exactly singular, and division by zero will occur if it is used to solve a system of equations.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gbstep</td><td>INTEGER internal use.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">batchCount</td><td>INTEGER The number of matrices to operate on.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>magma_queue_t Queue to execute in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4e1771f88d0042c0e8789019c3aad7a3" name="ga4e1771f88d0042c0e8789019c3aad7a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4e1771f88d0042c0e8789019c3aad7a3">&#9670;&#160;</a></span>magma_cgetrf_recpanel_native()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_cgetrf_recpanel_native </td>
          <td>(</td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>recnb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex_ptr&#160;</td>
          <td class="paramname"><em>dA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>dipiv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>dipivinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>dinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>gbstep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_event_t&#160;</td>
          <td class="paramname"><em>events</em>[2], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmagma__queue.html">magma_queue_t</a>&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmagma__queue.html">magma_queue_t</a>&#160;</td>
          <td class="paramname"><em>update_queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an internal routine. </p>
<p>CGETRF_PANEL computes an LU factorization of a general M-by-N matrix A using partial pivoting with row interchanges.</p>
<p>The factorization has the form A = P * L * U where P is a permutation matrix, L is lower triangular with unit diagonal elements (lower trapezoidal if m &gt; n), and U is upper triangular (upper trapezoidal if m &lt; n).</p>
<p>This is the right-looking Level 3 BLAS version of the algorithm.</p>
<p>This is a GPU-only routine. The host CPU is not used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>INTEGER The number of rows the matrix A. M &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>INTEGER The number of columns the matrix A. N &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dA</td><td>A COMPLEX array on the GPU, dimension (LDDA,N). On entry, an M-by-N matrix to be factored. On exit, the factors L and U from the factorization A = P*L*U; the unit diagonal elements of L are not stored.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldda</td><td>INTEGER The leading dimension of A. LDDA &gt;= max(1,M).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dipiv</td><td>An INTEGER array, dimension (min(M,N)) The pivot indices; for 1 &lt;= i &lt;= min(M,N), row i of the matrix was interchanged with row IPIV(i).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dipivinfo</td><td>An INTEGER array, for internal use.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dinfo</td><td>INTEGER, stored on the GPU<ul>
<li>= 0: successful exit</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value or another error occured, such as memory allocation failed.</li>
<li>&gt; 0: if INFO = i, U(i,i) is exactly zero. The factorization has been completed, but the factor U is exactly singular, and division by zero will occur if it is used to solve a system of equations.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gbstep</td><td>INTEGER internal use.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queues</td><td>Array of magma_queue_t, size 2 Queues to execute in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga284a4d90f1fb206aded3ca9462018013" name="ga284a4d90f1fb206aded3ca9462018013"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga284a4d90f1fb206aded3ca9462018013">&#9670;&#160;</a></span>magma_cgetrf_vbatched_max_nocheck_work()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_cgetrf_vbatched_max_nocheck_work </td>
          <td>(</td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>max_m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>max_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>max_minmn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>max_mxn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex **&#160;</td>
          <td class="paramname"><em>dA_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>ldda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t **&#160;</td>
          <td class="paramname"><em>dipiv_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>batchCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmagma__queue.html">magma_queue_t</a>&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>CGETRF computes an LU factorization of a general M-by-N matrix A using partial pivoting with row interchanges. </p>
<p>The factorization has the form A = P * L * U where P is a permutation matrix, L is lower triangular with unit diagonal elements (lower trapezoidal if m &gt; n), and U is upper triangular (upper trapezoidal if m &lt; n).</p>
<p>This is the right-looking Level 3 BLAS version of the algorithm.</p>
<p>This is the variable-size batched version, which factors batchCount matrices of different sizes in parallel. Each matrix is assumed to have its own size and leading dimension.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>Array of INTEGERs on the GPU, dimension (batchCount) Each is the number of rows of each matrix A. M[i] &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>Array of INTEGERs on the GPU, dimension (batchCount) Each is the number of columns of each matrix A. N[i] &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">MAX_M</td><td>INTEGER The maximum number of rows across the batch</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">MAX_N</td><td>INTEGER The maximum number of columns across the batch</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">MAX_MINMN</td><td>INTEGER The maximum value of min(Mi, Ni) for i = 1, 2, ..., batchCount</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">MAX_MxN</td><td>INTEGER The maximum value of the product (Mi x Ni) for i = 1, 2, ..., batchCount</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dA_array</td><td>Array of pointers on the GPU, dimension (batchCount). Each is a COMPLEX array on the GPU, dimension (LDDA[i],N[i]). On entry, each pointer is an M[i]-by-N[i] matrix to be factored. On exit, the factors L and U from the factorization A = P*L*U; the unit diagonal elements of L are not stored.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldda</td><td>Array of INTEGERs on the GPU Each is the leading dimension of each array A. LDDA[i] &gt;= max(1,M[i]).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dipiv_array</td><td>Array of pointers, dimension (batchCount), for corresponding matrices. Each is an INTEGER array, dimension (min(M[i],N[i])) The pivot indices; for 1 &lt;= p &lt;= min(M[i],N[i]), row p of the matrix was interchanged with row IPIV(p).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info_array</td><td>Array of INTEGERs, dimension (batchCount), for corresponding matrices.<ul>
<li>= 0: successful exit</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value or another error occured, such as memory allocation failed.</li>
<li>&gt; 0: if INFO = i, U(i,i) is exactly zero. The factorization has been completed, but the factor U is exactly singular, and division by zero will occur if it is used to solve a system of equations.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">WORK</td><td>VOID pointer A workspace of size LWORK[0]</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">LWORK</td><td>INTEGER pointer If lwork[0] &lt; 0, a workspace query is assumed, and lwork[0] is overwritten by the required workspace size in bytes. Otherwise, lwork[0] is the size of work</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">batchCount</td><td>INTEGER The number of matrices to operate on.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>magma_queue_t Queue to execute in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga61698c835989a877fcda119b0abb0b57" name="ga61698c835989a877fcda119b0abb0b57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga61698c835989a877fcda119b0abb0b57">&#9670;&#160;</a></span>magma_cgetrf_vbatched()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_cgetrf_vbatched </td>
          <td>(</td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex **&#160;</td>
          <td class="paramname"><em>dA_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>ldda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t **&#160;</td>
          <td class="paramname"><em>dipiv_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>batchCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmagma__queue.html">magma_queue_t</a>&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>CGETRF computes an LU factorization of a general M-by-N matrix A using partial pivoting with row interchanges. </p>
<p>The factorization has the form A = P * L * U where P is a permutation matrix, L is lower triangular with unit diagonal elements (lower trapezoidal if m &gt; n), and U is upper triangular (upper trapezoidal if m &lt; n).</p>
<p>This is the right-looking Level 3 BLAS version of the algorithm.</p>
<p>This is the variable-size batched version, which factors batchCount matrices of different sizes in parallel. Each matrix is assumed to have its own size and leading dimension.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>Array of INTEGERs on the GPU, dimension (batchCount) Each is the number of rows of each matrix A. M[i] &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>Array of INTEGERs on the GPU, dimension (batchCount) Each is the number of columns of each matrix A. N[i] &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dA_array</td><td>Array of pointers on the GPU, dimension (batchCount). Each is a COMPLEX array on the GPU, dimension (LDDA[i],N[i]). On entry, each pointer is an M[i]-by-N[i] matrix to be factored. On exit, the factors L and U from the factorization A = P*L*U; the unit diagonal elements of L are not stored.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldda</td><td>Array of INTEGERs on the GPU Each is the leading dimension of each array A. LDDA[i] &gt;= max(1,M[i]).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dipiv_array</td><td>Array of pointers, dimension (batchCount), for corresponding matrices. Each is an INTEGER array, dimension (min(M[i],N[i])) The pivot indices; for 1 &lt;= p &lt;= min(M[i],N[i]), row p of the matrix was interchanged with row IPIV(p).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info_array</td><td>Array of INTEGERs, dimension (batchCount), for corresponding matrices.<ul>
<li>= 0: successful exit</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value or another error occured, such as memory allocation failed.</li>
<li>&gt; 0: if INFO = i, U(i,i) is exactly zero. The factorization has been completed, but the factor U is exactly singular, and division by zero will occur if it is used to solve a system of equations.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">batchCount</td><td>INTEGER The number of matrices to operate on.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>magma_queue_t Queue to execute in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2f7298c3914756779363587a9d45fc4e" name="ga2f7298c3914756779363587a9d45fc4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f7298c3914756779363587a9d45fc4e">&#9670;&#160;</a></span>magma_dgbsv_batched_work()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_dgbsv_batched_work </td>
          <td>(</td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>kl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ku</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>nrhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>dA_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t **&#160;</td>
          <td class="paramname"><em>dipiv_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>dB_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lddb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>device_work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>batchCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmagma__queue.html">magma_queue_t</a>&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DGBSV computes the solution to a system of linear equations A * X = B, where A is a band matrix of order N with KL subdiagonals and KU superdiagonals, and X and B are N-by-NRHS matrices. </p>
<p>The LU decomposition with partial pivoting and row interchanges is used to factor A as A = L * U, where L is a product of permutation and unit lower triangular matrices with KL subdiagonals, and U is upper triangular with KL+KU superdiagonals. The factored form of A is then used to solve the system of equations A * X = B.</p>
<p>This is the batched version of the routine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>INTEGER The order of the matrix A. n &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kl</td><td>INTEGER The number of subdiagonals within the band of A. KL &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ku</td><td>INTEGER The number of superdiagonals within the band of A. KL &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nrhs</td><td>INTEGER The number of right hand sides, i.e., the number of columns of the matrix B. NRHS &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dA_array</td><td>Array of pointers, dimension (batchCount). Each contains the details of the LU factorization of the band matrix A, as computed by DGBTRF. U is stored as an upper triangular band matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and the multipliers used during the factorization are stored in rows KL+KU+2 to 2*KL+KU+1.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldda</td><td>INTEGER The leading dimension of each array A. LDDA &gt;= (2*KL+KU+1).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dipiv_array</td><td>Array of pointers, dimension (batchCount), for corresponding matrices. Each is an INTEGER array, dimension (min(M,N)) The pivot indices; for 1 &lt;= i &lt;= min(M,N), row i of the matrix was interchanged with row IPIV(i).</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dB_array</td><td>Array of pointers, dimension (batchCount). Each is a DOUBLE PRECISION array, dimension (LDB,NRHS) On entry, the right hand side matrix B. On exit, the solution matrix X.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lddb</td><td>INTEGER The leading dimension of each array B. LDDB &gt;= max(1, N).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info_array</td><td>Array of INTEGERs, dimension (batchCount), for corresponding matrices.<ul>
<li>= 0: successful exit</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value or another error occured, such as memory allocation failed. &gt; 0: if INFO = i, U(i,i) is exactly zero. The factorization has been completed, but the factor U is exactly singular, and the solution has not been computed.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">device_work</td><td>Workspace, allocated on device memory.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lwork</td><td>INTEGER pointer The size of the workspace (device_work) in bytes<ul>
<li>lwork[0] &lt; 0: a workspace query is assumed, the routine calculates the required amount of workspace and returns it in lwork. The workspace is not referenced, and no computation is performed.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>lwork[0] &gt;= 0: the routine assumes that the user has provided a workspace with the size in lwork.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">batchCount</td><td>INTEGER The number of matrices to operate on.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>magma_queue_t Queue to execute in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa422d21f8fb016cc65f4a9e05cbd9c7f" name="gaa422d21f8fb016cc65f4a9e05cbd9c7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa422d21f8fb016cc65f4a9e05cbd9c7f">&#9670;&#160;</a></span>magma_dgbsv_batched()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_dgbsv_batched </td>
          <td>(</td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>kl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ku</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>nrhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>dA_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t **&#160;</td>
          <td class="paramname"><em>dipiv_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>dB_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lddb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>batchCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmagma__queue.html">magma_queue_t</a>&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DGBSV computes the solution to a system of linear equations A * X = B, where A is a band matrix of order N with KL subdiagonals and KU superdiagonals, and X and B are N-by-NRHS matrices. </p>
<p>The LU decomposition with partial pivoting and row interchanges is used to factor A as A = L * U, where L is a product of permutation and unit lower triangular matrices with KL subdiagonals, and U is upper triangular with KL+KU superdiagonals. The factored form of A is then used to solve the system of equations A * X = B.</p>
<p>This is the batched version of the routine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>INTEGER The order of the matrix A. n &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kl</td><td>INTEGER The number of subdiagonals within the band of A. KL &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ku</td><td>INTEGER The number of superdiagonals within the band of A. KL &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nrhs</td><td>INTEGER The number of right hand sides, i.e., the number of columns of the matrix B. NRHS &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dA_array</td><td>Array of pointers, dimension (batchCount). Each contains the details of the LU factorization of the band matrix A, as computed by DGBTRF. U is stored as an upper triangular band matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and the multipliers used during the factorization are stored in rows KL+KU+2 to 2*KL+KU+1.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldda</td><td>INTEGER The leading dimension of each array A. LDDA &gt;= (2*KL+KU+1).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dipiv_array</td><td>Array of pointers, dimension (batchCount), for corresponding matrices. Each is an INTEGER array, dimension (min(M,N)) The pivot indices; for 1 &lt;= i &lt;= min(M,N), row i of the matrix was interchanged with row IPIV(i).</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dB_array</td><td>Array of pointers, dimension (batchCount). Each is a DOUBLE PRECISION array, dimension (LDB,NRHS) On entry, the right hand side matrix B. On exit, the solution matrix X.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lddb</td><td>INTEGER The leading dimension of each array B. LDDB &gt;= max(1, N).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info_array</td><td>Array of INTEGERs, dimension (batchCount), for corresponding matrices.<ul>
<li>= 0: successful exit</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value or another error occured, such as memory allocation failed.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">batchCount</td><td>INTEGER The number of matrices to operate on.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>magma_queue_t Queue to execute in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa0b9bd7edf6e8fdbf0fd94ea4a11f97e" name="gaa0b9bd7edf6e8fdbf0fd94ea4a11f97e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa0b9bd7edf6e8fdbf0fd94ea4a11f97e">&#9670;&#160;</a></span>magma_dgbtrf_batched_work()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_dgbtrf_batched_work </td>
          <td>(</td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>kl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ku</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>dAB_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lddab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t **&#160;</td>
          <td class="paramname"><em>dipiv_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>device_work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>batchCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmagma__queue.html">magma_queue_t</a>&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DGBTRF computes an LU factorization of a real m-by-n band matrix AB using partial pivoting with row interchanges. </p>
<p>This is a batched version that factors <code>batchCount</code> M-by-N matrices in parallel. dAB, dipiv, and info become arrays with one entry per matrix.</p>
<p>The band storage scheme is illustrated by the following example, when M = N = 6, KL = 2, KU = 1:</p>
<p>On entry: On exit: </p><pre class="fragment">    *    *    +    +    +       *    *    *   u14  u25  u36
    *    +    +    +    +       *    *   u13  u24  u35  u46
   a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56
</pre><p> a11 a22 a33 a44 a55 a66 u11 u22 u33 u44 u55 u66 a21 a32 a43 a54 a65 * m21 m32 m43 m54 m65 * a31 a42 a53 a64 * * m31 m42 m53 m64 * *</p>
<p>Note that this behavior is a little different from the standard LAPACK routine. Array elements marked * are not read by the routine, but may be zeroed out after completion. Elements marked + need not be set on entry, but are required by the routine to store elements of U because of fill-in resulting from the row interchanges.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>INTEGER The number of rows of each matrix A. M &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>INTEGER The number of columns of each matrix A. N &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kl</td><td>INTEGER The number of subdiagonals within the band of A. KL &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ku</td><td>INTEGER The number of superdiagonals within the band of A. KL &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dAB_array</td><td>Array of pointers, dimension (batchCount). Each is a DOUBLE PRECISION array on the GPU, dimension (LDAB,N) On entry, the matrix A in band storage, in rows KL+1 to 2*KL+KU+1; rows 1 to KL of the array need not be set. The j-th column of A is stored in the j-th column of the array AB as follows: AB(kl+ku+1+i-j,j) = A(i,j) for max(1,j-ku)&lt;=i&lt;=min(m,j+kl)</td></tr>
  </table>
  </dd>
</dl>
<p>On exit, details of the factorization: U is stored as an upper triangular band matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and the multipliers used during the factorization are stored in rows KL+KU+2 to 2*KL+KU+1. See above for details about the band storage.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lddab</td><td>INTEGER The leading dimension of each array AB. LDDAB &gt;= (2*KL+KU+1).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dipiv_array</td><td>Array of pointers, dimension (batchCount), for corresponding matrices. Each is an INTEGER array, dimension (min(M,N)) The pivot indices; for 1 &lt;= i &lt;= min(M,N), row i of the matrix was interchanged with row IPIV(i).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info_array</td><td>Array of INTEGERs, dimension (batchCount), for corresponding matrices.<ul>
<li>= 0: successful exit</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value or another error occured, such as memory allocation failed.</li>
<li>&gt; 0: if INFO = i, U(i,i) is exactly zero. The factorization has been completed, but the factor U is exactly singular, and division by zero will occur if it is used to solve a system of equations.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">device_work</td><td>Workspace, allocated on device memory</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lwork</td><td>INTEGER pointer The size of the workspace (device_work) in bytes<ul>
<li>lwork[0] &lt; 0: a workspace query is assumed, the routine calculates the required amount of workspace and returns it in lwork. The workspace is not referenced, and no factorization is performed.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>lwork[0] &gt;= 0: the routine assumes that the user has provided a workspace with the size in lwork.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">batchCount</td><td>INTEGER The number of matrices to operate on.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>magma_queue_t Queue to execute in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga192b742fccb2bbdb4d7dcb5f3d1f349a" name="ga192b742fccb2bbdb4d7dcb5f3d1f349a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga192b742fccb2bbdb4d7dcb5f3d1f349a">&#9670;&#160;</a></span>magma_dgbtrf_batched()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_dgbtrf_batched </td>
          <td>(</td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>kl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ku</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>dAB_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lddab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t **&#160;</td>
          <td class="paramname"><em>dipiv_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>batchCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmagma__queue.html">magma_queue_t</a>&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DGBTRF computes an LU factorization of a COMPLEX m-by-n band matrix A using partial pivoting with row interchanges. </p>
<p>This is the batched version of the algorithm, which performs the factorization on a batch of matrices with the same size and lower/upper bandwidths.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>INTEGER The number of rows of the matrix A. M &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>INTEGER The number of columns of the matrix A. N &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">KL</td><td>INTEGER The number of subdiagonals within the band of A. KL &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">KU</td><td>INTEGER The number of superdiagonals within the band of A. KU &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dAB_array</td><td>Array of pointers, dimension (batchCount). Each is a DOUBLE PRECISION array, dimension (LDDAB,N) On entry, the matrix AB in band storage, in rows KL+1 to 2*KL+KU+1; rows 1 to KL of the array need not be set. The j-th column of A is stored in the j-th column of the array AB as follows: AB(kl+ku+1+i-j,j) = A(i,j) for max(1,j-ku)&lt;=i&lt;=min(m,j+kl)</td></tr>
  </table>
  </dd>
</dl>
<p>On exit, details of the factorization: U is stored as an upper triangular band matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and the multipliers used during the factorization are stored in rows KL+KU+2 to 2*KL+KU+1. See below for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">LDDAB</td><td>INTEGER The leading dimension of the array AB. LDAB &gt;= 2*KL+KU+1.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dIPIV_array</td><td>Array of pointers, dimension (batchCount). Each is an INTEGER array, dimension (min(M,N)) The pivot indices; for 1 &lt;= i &lt;= min(M,N), row i of the matrix was interchanged with row IPIV(i).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dINFO_array</td><td>INTEGER array, dimension (batchCount) Each is the INFO output for a given matrix = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value &gt; 0: if INFO = +i, U(i,i) is exactly zero. The factorization has been completed, but the factor U is exactly singular, and division by zero will occur if it is used to solve a system of equations.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">batchCount</td><td>INTEGER The number of matrices to operate on.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>magma_queue_t Queue to execute in.</td></tr>
  </table>
  </dd>
</dl>
<h1><a class="anchor" id="autotoc_md95"></a>
Further Details</h1>
<p>The band storage scheme is illustrated by the following example, when M = N = 6, KL = 2, KU = 1:</p>
<p>On entry: On exit: </p><pre class="fragment">     *    *    +    +    +       *    *    *   u14  u25  u36
     *    +    +    +    +       *    *   u13  u24  u35  u46
    a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56
</pre><p> a11 a22 a33 a44 a55 a66 u11 u22 u33 u44 u55 u66 a21 a32 a43 a54 a65 * m21 m32 m43 m54 m65 * a31 a42 a53 a64 * * m31 m42 m53 m64 * *</p>
<p>Array elements marked * are not used by the routine; elements marked</p><ul>
<li>need not be set on entry, but are required by the routine to store elements of U because of fill-in resulting from the row interchanges. </li>
</ul>

</div>
</div>
<a id="gabc4f87c8d102b2cdc6a93a16e865db56" name="gabc4f87c8d102b2cdc6a93a16e865db56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc4f87c8d102b2cdc6a93a16e865db56">&#9670;&#160;</a></span>magma_dgbtrs_batched()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_dgbtrs_batched </td>
          <td>(</td>
          <td class="paramtype">magma_trans_t&#160;</td>
          <td class="paramname"><em>transA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>kl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ku</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>nrhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>dA_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t **&#160;</td>
          <td class="paramname"><em>dipiv_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>dB_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lddb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>batchCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmagma__queue.html">magma_queue_t</a>&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DGBTRS solves a system of linear equations A * X = B, A**T * X = B, or A**H * X = B with a general band matrix A using the LU factorization computed by DGBTRF. </p>
<p>This is the batched version of the routine. Currently, only (A * X = B) is supported (no-trans only)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">transA</td><td>magma_trans_t Specifies the form of the system of equations. Currently, only MagnaNoTrans is supported (A*X = B)</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>INTEGER The order of the matrix A. n &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kl</td><td>INTEGER The number of subdiagonals within the band of A. KL &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ku</td><td>INTEGER The number of superdiagonals within the band of A. KL &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nrhs</td><td>INTEGER The number of right hand sides, i.e., the number of columns of the matrix B. NRHS &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dA_array</td><td>Array of pointers, dimension (batchCount). Each contains the details of the LU factorization of the band matrix A, as computed by DGBTRF. U is stored as an upper triangular band matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and the multipliers used during the factorization are stored in rows KL+KU+2 to 2*KL+KU+1.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldda</td><td>INTEGER The leading dimension of each array A. LDDA &gt;= (2*KL+KU+1).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dipiv_array</td><td>Array of pointers, dimension (batchCount), for corresponding matrices. Each is an INTEGER array, dimension (min(M,N)) The pivot indices; for 1 &lt;= i &lt;= min(M,N), row i of the matrix was interchanged with row IPIV(i).</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dB_array</td><td>Array of pointers, dimension (batchCount). Each is a DOUBLE PRECISION array, dimension (LDB,NRHS) On entry, the right hand side matrix B. On exit, the solution matrix X.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lddb</td><td>INTEGER The leading dimension of each array B. LDDB &gt;= max(1, N).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info_array</td><td>Array of INTEGERs, dimension (batchCount), for corresponding matrices.<ul>
<li>= 0: successful exit</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value or another error occured, such as memory allocation failed.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">batchCount</td><td>INTEGER The number of matrices to operate on.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>magma_queue_t Queue to execute in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3c8feaafa83444639c86779e42510298" name="ga3c8feaafa83444639c86779e42510298"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3c8feaafa83444639c86779e42510298">&#9670;&#160;</a></span>magma_dgetrf_batched()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_dgetrf_batched </td>
          <td>(</td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>dA_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t **&#160;</td>
          <td class="paramname"><em>ipiv_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>batchCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmagma__queue.html">magma_queue_t</a>&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DGETRF computes an LU factorization of a general M-by-N matrix A using partial pivoting with row interchanges. </p>
<p>The factorization has the form A = P * L * U where P is a permutation matrix, L is lower triangular with unit diagonal elements (lower trapezoidal if m &gt; n), and U is upper triangular (upper trapezoidal if m &lt; n).</p>
<p>This is the right-looking Level 3 BLAS version of the algorithm.</p>
<p>This is a batched version that factors batchCount M-by-N matrices in parallel. dA, ipiv, and info become arrays with one entry per matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>INTEGER The number of rows of each matrix A. M &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>INTEGER The number of columns of each matrix A. N &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dA_array</td><td>Array of pointers, dimension (batchCount). Each is a DOUBLE PRECISION array on the GPU, dimension (LDDA,N). On entry, each pointer is an M-by-N matrix to be factored. On exit, the factors L and U from the factorization A = P*L*U; the unit diagonal elements of L are not stored.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldda</td><td>INTEGER The leading dimension of each array A. LDDA &gt;= max(1,M).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ipiv_array</td><td>Array of pointers, dimension (batchCount), for corresponding matrices. Each is an INTEGER array, dimension (min(M,N)) The pivot indices; for 1 &lt;= i &lt;= min(M,N), row i of the matrix was interchanged with row IPIV(i).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info_array</td><td>Array of INTEGERs, dimension (batchCount), for corresponding matrices.<ul>
<li>= 0: successful exit</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value or another error occured, such as memory allocation failed.</li>
<li>&gt; 0: if INFO = i, U(i,i) is exactly zero. The factorization has been completed, but the factor U is exactly singular, and division by zero will occur if it is used to solve a system of equations.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">batchCount</td><td>INTEGER The number of matrices to operate on.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>magma_queue_t Queue to execute in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4efed876a89ed9400560027dac193473" name="ga4efed876a89ed9400560027dac193473"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4efed876a89ed9400560027dac193473">&#9670;&#160;</a></span>magma_dgetrf_recpanel_batched()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_dgetrf_recpanel_batched </td>
          <td>(</td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>min_recpnb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>dA_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ai</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>aj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t **&#160;</td>
          <td class="paramname"><em>dipiv_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t **&#160;</td>
          <td class="paramname"><em>dpivinfo_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>gbstep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>batchCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmagma__queue.html">magma_queue_t</a>&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an internal routine that might have many assumption. </p>
<p>Documentation is not fully completed</p>
<p>DGETRF_PANEL computes an LU factorization of a general M-by-N matrix A using partial pivoting with row interchanges.</p>
<p>The factorization has the form A = P * L * U where P is a permutation matrix, L is lower triangular with unit diagonal elements (lower trapezoidal if m &gt; n), and U is upper triangular (upper trapezoidal if m &lt; n).</p>
<p>This is the right-looking Level 3 BLAS version of the algorithm.</p>
<p>This is a batched version that factors batchCount M-by-N matrices in parallel. dA, ipiv, and info become arrays with one entry per matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>INTEGER The number of rows of each matrix A. M &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>INTEGER The number of columns of each matrix A. N &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">min_recpnb</td><td>INTEGER. Internal use. The recursive nb</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dA_array</td><td>Array of pointers, dimension (batchCount). Each is a DOUBLE PRECISION array on the GPU, dimension (LDDA,N). On entry, each pointer is an M-by-N matrix to be factored. On exit, the factors L and U from the factorization A = P*L*U; the unit diagonal elements of L are not stored.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ai</td><td>INTEGER Row offset for A.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aj</td><td>INTEGER Column offset for A.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldda</td><td>INTEGER The leading dimension of each array A. LDDA &gt;= max(1,M).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dipiv_array</td><td>Array of pointers, dimension (batchCount), for corresponding matrices. Each is an INTEGER array, dimension (min(M,N)) The pivot indices; for 1 &lt;= i &lt;= min(M,N), row i of the matrix was interchanged with row IPIV(i).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dpivinfo_array</td><td>Array of pointers, dimension (batchCount), for internal use.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info_array</td><td>Array of INTEGERs, dimension (batchCount), for corresponding matrices.<ul>
<li>= 0: successful exit</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value or another error occured, such as memory allocation failed.</li>
<li>&gt; 0: if INFO = i, U(i,i) is exactly zero. The factorization has been completed, but the factor U is exactly singular, and division by zero will occur if it is used to solve a system of equations.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gbstep</td><td>INTEGER internal use.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">batchCount</td><td>INTEGER The number of matrices to operate on.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>magma_queue_t Queue to execute in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga43f4d978c91ab804c0267cfc909ebd10" name="ga43f4d978c91ab804c0267cfc909ebd10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga43f4d978c91ab804c0267cfc909ebd10">&#9670;&#160;</a></span>magma_dgetrf_recpanel_native()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_dgetrf_recpanel_native </td>
          <td>(</td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>recnb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaDouble_ptr&#160;</td>
          <td class="paramname"><em>dA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>dipiv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>dipivinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>dinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>gbstep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_event_t&#160;</td>
          <td class="paramname"><em>events</em>[2], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmagma__queue.html">magma_queue_t</a>&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmagma__queue.html">magma_queue_t</a>&#160;</td>
          <td class="paramname"><em>update_queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an internal routine. </p>
<p>DGETRF_PANEL computes an LU factorization of a general M-by-N matrix A using partial pivoting with row interchanges.</p>
<p>The factorization has the form A = P * L * U where P is a permutation matrix, L is lower triangular with unit diagonal elements (lower trapezoidal if m &gt; n), and U is upper triangular (upper trapezoidal if m &lt; n).</p>
<p>This is the right-looking Level 3 BLAS version of the algorithm.</p>
<p>This is a GPU-only routine. The host CPU is not used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>INTEGER The number of rows the matrix A. M &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>INTEGER The number of columns the matrix A. N &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dA</td><td>A DOUBLE PRECISION array on the GPU, dimension (LDDA,N). On entry, an M-by-N matrix to be factored. On exit, the factors L and U from the factorization A = P*L*U; the unit diagonal elements of L are not stored.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldda</td><td>INTEGER The leading dimension of A. LDDA &gt;= max(1,M).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dipiv</td><td>An INTEGER array, dimension (min(M,N)) The pivot indices; for 1 &lt;= i &lt;= min(M,N), row i of the matrix was interchanged with row IPIV(i).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dipivinfo</td><td>An INTEGER array, for internal use.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dinfo</td><td>INTEGER, stored on the GPU<ul>
<li>= 0: successful exit</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value or another error occured, such as memory allocation failed.</li>
<li>&gt; 0: if INFO = i, U(i,i) is exactly zero. The factorization has been completed, but the factor U is exactly singular, and division by zero will occur if it is used to solve a system of equations.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gbstep</td><td>INTEGER internal use.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queues</td><td>Array of magma_queue_t, size 2 Queues to execute in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga606dea50c55fe82d7192b7691d4dd4d6" name="ga606dea50c55fe82d7192b7691d4dd4d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga606dea50c55fe82d7192b7691d4dd4d6">&#9670;&#160;</a></span>magma_dgetrf_vbatched_max_nocheck_work()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_dgetrf_vbatched_max_nocheck_work </td>
          <td>(</td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>max_m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>max_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>max_minmn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>max_mxn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>dA_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>ldda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t **&#160;</td>
          <td class="paramname"><em>dipiv_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>batchCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmagma__queue.html">magma_queue_t</a>&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DGETRF computes an LU factorization of a general M-by-N matrix A using partial pivoting with row interchanges. </p>
<p>The factorization has the form A = P * L * U where P is a permutation matrix, L is lower triangular with unit diagonal elements (lower trapezoidal if m &gt; n), and U is upper triangular (upper trapezoidal if m &lt; n).</p>
<p>This is the right-looking Level 3 BLAS version of the algorithm.</p>
<p>This is the variable-size batched version, which factors batchCount matrices of different sizes in parallel. Each matrix is assumed to have its own size and leading dimension.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>Array of INTEGERs on the GPU, dimension (batchCount) Each is the number of rows of each matrix A. M[i] &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>Array of INTEGERs on the GPU, dimension (batchCount) Each is the number of columns of each matrix A. N[i] &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">MAX_M</td><td>INTEGER The maximum number of rows across the batch</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">MAX_N</td><td>INTEGER The maximum number of columns across the batch</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">MAX_MINMN</td><td>INTEGER The maximum value of min(Mi, Ni) for i = 1, 2, ..., batchCount</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">MAX_MxN</td><td>INTEGER The maximum value of the product (Mi x Ni) for i = 1, 2, ..., batchCount</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dA_array</td><td>Array of pointers on the GPU, dimension (batchCount). Each is a DOUBLE PRECISION array on the GPU, dimension (LDDA[i],N[i]). On entry, each pointer is an M[i]-by-N[i] matrix to be factored. On exit, the factors L and U from the factorization A = P*L*U; the unit diagonal elements of L are not stored.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldda</td><td>Array of INTEGERs on the GPU Each is the leading dimension of each array A. LDDA[i] &gt;= max(1,M[i]).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dipiv_array</td><td>Array of pointers, dimension (batchCount), for corresponding matrices. Each is an INTEGER array, dimension (min(M[i],N[i])) The pivot indices; for 1 &lt;= p &lt;= min(M[i],N[i]), row p of the matrix was interchanged with row IPIV(p).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info_array</td><td>Array of INTEGERs, dimension (batchCount), for corresponding matrices.<ul>
<li>= 0: successful exit</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value or another error occured, such as memory allocation failed.</li>
<li>&gt; 0: if INFO = i, U(i,i) is exactly zero. The factorization has been completed, but the factor U is exactly singular, and division by zero will occur if it is used to solve a system of equations.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">WORK</td><td>VOID pointer A workspace of size LWORK[0]</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">LWORK</td><td>INTEGER pointer If lwork[0] &lt; 0, a workspace query is assumed, and lwork[0] is overwritten by the required workspace size in bytes. Otherwise, lwork[0] is the size of work</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">batchCount</td><td>INTEGER The number of matrices to operate on.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>magma_queue_t Queue to execute in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gace18ffd8f99c360904a4b6e2c088ea7c" name="gace18ffd8f99c360904a4b6e2c088ea7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gace18ffd8f99c360904a4b6e2c088ea7c">&#9670;&#160;</a></span>magma_dgetrf_vbatched()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_dgetrf_vbatched </td>
          <td>(</td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>dA_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>ldda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t **&#160;</td>
          <td class="paramname"><em>dipiv_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>batchCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmagma__queue.html">magma_queue_t</a>&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DGETRF computes an LU factorization of a general M-by-N matrix A using partial pivoting with row interchanges. </p>
<p>The factorization has the form A = P * L * U where P is a permutation matrix, L is lower triangular with unit diagonal elements (lower trapezoidal if m &gt; n), and U is upper triangular (upper trapezoidal if m &lt; n).</p>
<p>This is the right-looking Level 3 BLAS version of the algorithm.</p>
<p>This is the variable-size batched version, which factors batchCount matrices of different sizes in parallel. Each matrix is assumed to have its own size and leading dimension.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>Array of INTEGERs on the GPU, dimension (batchCount) Each is the number of rows of each matrix A. M[i] &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>Array of INTEGERs on the GPU, dimension (batchCount) Each is the number of columns of each matrix A. N[i] &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dA_array</td><td>Array of pointers on the GPU, dimension (batchCount). Each is a DOUBLE PRECISION array on the GPU, dimension (LDDA[i],N[i]). On entry, each pointer is an M[i]-by-N[i] matrix to be factored. On exit, the factors L and U from the factorization A = P*L*U; the unit diagonal elements of L are not stored.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldda</td><td>Array of INTEGERs on the GPU Each is the leading dimension of each array A. LDDA[i] &gt;= max(1,M[i]).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dipiv_array</td><td>Array of pointers, dimension (batchCount), for corresponding matrices. Each is an INTEGER array, dimension (min(M[i],N[i])) The pivot indices; for 1 &lt;= p &lt;= min(M[i],N[i]), row p of the matrix was interchanged with row IPIV(p).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info_array</td><td>Array of INTEGERs, dimension (batchCount), for corresponding matrices.<ul>
<li>= 0: successful exit</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value or another error occured, such as memory allocation failed.</li>
<li>&gt; 0: if INFO = i, U(i,i) is exactly zero. The factorization has been completed, but the factor U is exactly singular, and division by zero will occur if it is used to solve a system of equations.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">batchCount</td><td>INTEGER The number of matrices to operate on.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>magma_queue_t Queue to execute in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0fa974b09ba2eeecf5e6cd207e719abf" name="ga0fa974b09ba2eeecf5e6cd207e719abf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0fa974b09ba2eeecf5e6cd207e719abf">&#9670;&#160;</a></span>magma_sgbsv_batched_work()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_sgbsv_batched_work </td>
          <td>(</td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>kl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ku</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>nrhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float **&#160;</td>
          <td class="paramname"><em>dA_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t **&#160;</td>
          <td class="paramname"><em>dipiv_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float **&#160;</td>
          <td class="paramname"><em>dB_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lddb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>device_work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>batchCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmagma__queue.html">magma_queue_t</a>&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SGBSV computes the solution to a system of linear equations A * X = B, where A is a band matrix of order N with KL subdiagonals and KU superdiagonals, and X and B are N-by-NRHS matrices. </p>
<p>The LU decomposition with partial pivoting and row interchanges is used to factor A as A = L * U, where L is a product of permutation and unit lower triangular matrices with KL subdiagonals, and U is upper triangular with KL+KU superdiagonals. The factored form of A is then used to solve the system of equations A * X = B.</p>
<p>This is the batched version of the routine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>INTEGER The order of the matrix A. n &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kl</td><td>INTEGER The number of subdiagonals within the band of A. KL &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ku</td><td>INTEGER The number of superdiagonals within the band of A. KL &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nrhs</td><td>INTEGER The number of right hand sides, i.e., the number of columns of the matrix B. NRHS &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dA_array</td><td>Array of pointers, dimension (batchCount). Each contains the details of the LU factorization of the band matrix A, as computed by SGBTRF. U is stored as an upper triangular band matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and the multipliers used during the factorization are stored in rows KL+KU+2 to 2*KL+KU+1.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldda</td><td>INTEGER The leading dimension of each array A. LDDA &gt;= (2*KL+KU+1).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dipiv_array</td><td>Array of pointers, dimension (batchCount), for corresponding matrices. Each is an INTEGER array, dimension (min(M,N)) The pivot indices; for 1 &lt;= i &lt;= min(M,N), row i of the matrix was interchanged with row IPIV(i).</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dB_array</td><td>Array of pointers, dimension (batchCount). Each is a REAL array, dimension (LDB,NRHS) On entry, the right hand side matrix B. On exit, the solution matrix X.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lddb</td><td>INTEGER The leading dimension of each array B. LDDB &gt;= max(1, N).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info_array</td><td>Array of INTEGERs, dimension (batchCount), for corresponding matrices.<ul>
<li>= 0: successful exit</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value or another error occured, such as memory allocation failed. &gt; 0: if INFO = i, U(i,i) is exactly zero. The factorization has been completed, but the factor U is exactly singular, and the solution has not been computed.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">device_work</td><td>Workspace, allocated on device memory.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lwork</td><td>INTEGER pointer The size of the workspace (device_work) in bytes<ul>
<li>lwork[0] &lt; 0: a workspace query is assumed, the routine calculates the required amount of workspace and returns it in lwork. The workspace is not referenced, and no computation is performed.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>lwork[0] &gt;= 0: the routine assumes that the user has provided a workspace with the size in lwork.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">batchCount</td><td>INTEGER The number of matrices to operate on.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>magma_queue_t Queue to execute in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6f2ae9d536a2ba061070590302a78ea1" name="ga6f2ae9d536a2ba061070590302a78ea1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6f2ae9d536a2ba061070590302a78ea1">&#9670;&#160;</a></span>magma_sgbsv_batched()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_sgbsv_batched </td>
          <td>(</td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>kl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ku</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>nrhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float **&#160;</td>
          <td class="paramname"><em>dA_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t **&#160;</td>
          <td class="paramname"><em>dipiv_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float **&#160;</td>
          <td class="paramname"><em>dB_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lddb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>batchCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmagma__queue.html">magma_queue_t</a>&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SGBSV computes the solution to a system of linear equations A * X = B, where A is a band matrix of order N with KL subdiagonals and KU superdiagonals, and X and B are N-by-NRHS matrices. </p>
<p>The LU decomposition with partial pivoting and row interchanges is used to factor A as A = L * U, where L is a product of permutation and unit lower triangular matrices with KL subdiagonals, and U is upper triangular with KL+KU superdiagonals. The factored form of A is then used to solve the system of equations A * X = B.</p>
<p>This is the batched version of the routine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>INTEGER The order of the matrix A. n &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kl</td><td>INTEGER The number of subdiagonals within the band of A. KL &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ku</td><td>INTEGER The number of superdiagonals within the band of A. KL &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nrhs</td><td>INTEGER The number of right hand sides, i.e., the number of columns of the matrix B. NRHS &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dA_array</td><td>Array of pointers, dimension (batchCount). Each contains the details of the LU factorization of the band matrix A, as computed by SGBTRF. U is stored as an upper triangular band matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and the multipliers used during the factorization are stored in rows KL+KU+2 to 2*KL+KU+1.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldda</td><td>INTEGER The leading dimension of each array A. LDDA &gt;= (2*KL+KU+1).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dipiv_array</td><td>Array of pointers, dimension (batchCount), for corresponding matrices. Each is an INTEGER array, dimension (min(M,N)) The pivot indices; for 1 &lt;= i &lt;= min(M,N), row i of the matrix was interchanged with row IPIV(i).</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dB_array</td><td>Array of pointers, dimension (batchCount). Each is a REAL array, dimension (LDB,NRHS) On entry, the right hand side matrix B. On exit, the solution matrix X.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lddb</td><td>INTEGER The leading dimension of each array B. LDDB &gt;= max(1, N).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info_array</td><td>Array of INTEGERs, dimension (batchCount), for corresponding matrices.<ul>
<li>= 0: successful exit</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value or another error occured, such as memory allocation failed.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">batchCount</td><td>INTEGER The number of matrices to operate on.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>magma_queue_t Queue to execute in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaeb4f407757f60edc4424b9df76f7438a" name="gaeb4f407757f60edc4424b9df76f7438a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeb4f407757f60edc4424b9df76f7438a">&#9670;&#160;</a></span>magma_sgbtrf_batched_work()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_sgbtrf_batched_work </td>
          <td>(</td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>kl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ku</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float **&#160;</td>
          <td class="paramname"><em>dAB_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lddab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t **&#160;</td>
          <td class="paramname"><em>dipiv_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>device_work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>batchCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmagma__queue.html">magma_queue_t</a>&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SGBTRF computes an LU factorization of a real m-by-n band matrix AB using partial pivoting with row interchanges. </p>
<p>This is a batched version that factors <code>batchCount</code> M-by-N matrices in parallel. dAB, dipiv, and info become arrays with one entry per matrix.</p>
<p>The band storage scheme is illustrated by the following example, when M = N = 6, KL = 2, KU = 1:</p>
<p>On entry: On exit: </p><pre class="fragment">    *    *    +    +    +       *    *    *   u14  u25  u36
    *    +    +    +    +       *    *   u13  u24  u35  u46
   a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56
</pre><p> a11 a22 a33 a44 a55 a66 u11 u22 u33 u44 u55 u66 a21 a32 a43 a54 a65 * m21 m32 m43 m54 m65 * a31 a42 a53 a64 * * m31 m42 m53 m64 * *</p>
<p>Note that this behavior is a little different from the standard LAPACK routine. Array elements marked * are not read by the routine, but may be zeroed out after completion. Elements marked + need not be set on entry, but are required by the routine to store elements of U because of fill-in resulting from the row interchanges.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>INTEGER The number of rows of each matrix A. M &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>INTEGER The number of columns of each matrix A. N &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kl</td><td>INTEGER The number of subdiagonals within the band of A. KL &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ku</td><td>INTEGER The number of superdiagonals within the band of A. KL &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dAB_array</td><td>Array of pointers, dimension (batchCount). Each is a REAL array on the GPU, dimension (LDAB,N) On entry, the matrix A in band storage, in rows KL+1 to 2*KL+KU+1; rows 1 to KL of the array need not be set. The j-th column of A is stored in the j-th column of the array AB as follows: AB(kl+ku+1+i-j,j) = A(i,j) for max(1,j-ku)&lt;=i&lt;=min(m,j+kl)</td></tr>
  </table>
  </dd>
</dl>
<p>On exit, details of the factorization: U is stored as an upper triangular band matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and the multipliers used during the factorization are stored in rows KL+KU+2 to 2*KL+KU+1. See above for details about the band storage.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lddab</td><td>INTEGER The leading dimension of each array AB. LDDAB &gt;= (2*KL+KU+1).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dipiv_array</td><td>Array of pointers, dimension (batchCount), for corresponding matrices. Each is an INTEGER array, dimension (min(M,N)) The pivot indices; for 1 &lt;= i &lt;= min(M,N), row i of the matrix was interchanged with row IPIV(i).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info_array</td><td>Array of INTEGERs, dimension (batchCount), for corresponding matrices.<ul>
<li>= 0: successful exit</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value or another error occured, such as memory allocation failed.</li>
<li>&gt; 0: if INFO = i, U(i,i) is exactly zero. The factorization has been completed, but the factor U is exactly singular, and division by zero will occur if it is used to solve a system of equations.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">device_work</td><td>Workspace, allocated on device memory</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lwork</td><td>INTEGER pointer The size of the workspace (device_work) in bytes<ul>
<li>lwork[0] &lt; 0: a workspace query is assumed, the routine calculates the required amount of workspace and returns it in lwork. The workspace is not referenced, and no factorization is performed.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>lwork[0] &gt;= 0: the routine assumes that the user has provided a workspace with the size in lwork.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">batchCount</td><td>INTEGER The number of matrices to operate on.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>magma_queue_t Queue to execute in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0b251813d6af1cc89478e12e45b2b41e" name="ga0b251813d6af1cc89478e12e45b2b41e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0b251813d6af1cc89478e12e45b2b41e">&#9670;&#160;</a></span>magma_sgbtrf_batched()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_sgbtrf_batched </td>
          <td>(</td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>kl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ku</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float **&#160;</td>
          <td class="paramname"><em>dAB_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lddab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t **&#160;</td>
          <td class="paramname"><em>dipiv_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>batchCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmagma__queue.html">magma_queue_t</a>&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SGBTRF computes an LU factorization of a COMPLEX m-by-n band matrix A using partial pivoting with row interchanges. </p>
<p>This is the batched version of the algorithm, which performs the factorization on a batch of matrices with the same size and lower/upper bandwidths.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>INTEGER The number of rows of the matrix A. M &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>INTEGER The number of columns of the matrix A. N &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">KL</td><td>INTEGER The number of subdiagonals within the band of A. KL &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">KU</td><td>INTEGER The number of superdiagonals within the band of A. KU &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dAB_array</td><td>Array of pointers, dimension (batchCount). Each is a REAL array, dimension (LDDAB,N) On entry, the matrix AB in band storage, in rows KL+1 to 2*KL+KU+1; rows 1 to KL of the array need not be set. The j-th column of A is stored in the j-th column of the array AB as follows: AB(kl+ku+1+i-j,j) = A(i,j) for max(1,j-ku)&lt;=i&lt;=min(m,j+kl)</td></tr>
  </table>
  </dd>
</dl>
<p>On exit, details of the factorization: U is stored as an upper triangular band matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and the multipliers used during the factorization are stored in rows KL+KU+2 to 2*KL+KU+1. See below for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">LDDAB</td><td>INTEGER The leading dimension of the array AB. LDAB &gt;= 2*KL+KU+1.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dIPIV_array</td><td>Array of pointers, dimension (batchCount). Each is an INTEGER array, dimension (min(M,N)) The pivot indices; for 1 &lt;= i &lt;= min(M,N), row i of the matrix was interchanged with row IPIV(i).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dINFO_array</td><td>INTEGER array, dimension (batchCount) Each is the INFO output for a given matrix = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value &gt; 0: if INFO = +i, U(i,i) is exactly zero. The factorization has been completed, but the factor U is exactly singular, and division by zero will occur if it is used to solve a system of equations.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">batchCount</td><td>INTEGER The number of matrices to operate on.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>magma_queue_t Queue to execute in.</td></tr>
  </table>
  </dd>
</dl>
<h1><a class="anchor" id="autotoc_md168"></a>
Further Details</h1>
<p>The band storage scheme is illustrated by the following example, when M = N = 6, KL = 2, KU = 1:</p>
<p>On entry: On exit: </p><pre class="fragment">     *    *    +    +    +       *    *    *   u14  u25  u36
     *    +    +    +    +       *    *   u13  u24  u35  u46
    a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56
</pre><p> a11 a22 a33 a44 a55 a66 u11 u22 u33 u44 u55 u66 a21 a32 a43 a54 a65 * m21 m32 m43 m54 m65 * a31 a42 a53 a64 * * m31 m42 m53 m64 * *</p>
<p>Array elements marked * are not used by the routine; elements marked</p><ul>
<li>need not be set on entry, but are required by the routine to store elements of U because of fill-in resulting from the row interchanges. </li>
</ul>

</div>
</div>
<a id="gae03279394dfe5119906556ad182b597f" name="gae03279394dfe5119906556ad182b597f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae03279394dfe5119906556ad182b597f">&#9670;&#160;</a></span>magma_sgbtrs_batched()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_sgbtrs_batched </td>
          <td>(</td>
          <td class="paramtype">magma_trans_t&#160;</td>
          <td class="paramname"><em>transA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>kl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ku</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>nrhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float **&#160;</td>
          <td class="paramname"><em>dA_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t **&#160;</td>
          <td class="paramname"><em>dipiv_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float **&#160;</td>
          <td class="paramname"><em>dB_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lddb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>batchCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmagma__queue.html">magma_queue_t</a>&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SGBTRS solves a system of linear equations A * X = B, A**T * X = B, or A**H * X = B with a general band matrix A using the LU factorization computed by SGBTRF. </p>
<p>This is the batched version of the routine. Currently, only (A * X = B) is supported (no-trans only)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">transA</td><td>magma_trans_t Specifies the form of the system of equations. Currently, only MagnaNoTrans is supported (A*X = B)</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>INTEGER The order of the matrix A. n &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kl</td><td>INTEGER The number of subdiagonals within the band of A. KL &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ku</td><td>INTEGER The number of superdiagonals within the band of A. KL &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nrhs</td><td>INTEGER The number of right hand sides, i.e., the number of columns of the matrix B. NRHS &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dA_array</td><td>Array of pointers, dimension (batchCount). Each contains the details of the LU factorization of the band matrix A, as computed by SGBTRF. U is stored as an upper triangular band matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and the multipliers used during the factorization are stored in rows KL+KU+2 to 2*KL+KU+1.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldda</td><td>INTEGER The leading dimension of each array A. LDDA &gt;= (2*KL+KU+1).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dipiv_array</td><td>Array of pointers, dimension (batchCount), for corresponding matrices. Each is an INTEGER array, dimension (min(M,N)) The pivot indices; for 1 &lt;= i &lt;= min(M,N), row i of the matrix was interchanged with row IPIV(i).</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dB_array</td><td>Array of pointers, dimension (batchCount). Each is a REAL array, dimension (LDB,NRHS) On entry, the right hand side matrix B. On exit, the solution matrix X.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lddb</td><td>INTEGER The leading dimension of each array B. LDDB &gt;= max(1, N).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info_array</td><td>Array of INTEGERs, dimension (batchCount), for corresponding matrices.<ul>
<li>= 0: successful exit</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value or another error occured, such as memory allocation failed.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">batchCount</td><td>INTEGER The number of matrices to operate on.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>magma_queue_t Queue to execute in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga79368ca75f446be8b186683e01dfa66e" name="ga79368ca75f446be8b186683e01dfa66e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga79368ca75f446be8b186683e01dfa66e">&#9670;&#160;</a></span>magma_sgetrf_batched()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_sgetrf_batched </td>
          <td>(</td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float **&#160;</td>
          <td class="paramname"><em>dA_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t **&#160;</td>
          <td class="paramname"><em>ipiv_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>batchCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmagma__queue.html">magma_queue_t</a>&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SGETRF computes an LU factorization of a general M-by-N matrix A using partial pivoting with row interchanges. </p>
<p>The factorization has the form A = P * L * U where P is a permutation matrix, L is lower triangular with unit diagonal elements (lower trapezoidal if m &gt; n), and U is upper triangular (upper trapezoidal if m &lt; n).</p>
<p>This is the right-looking Level 3 BLAS version of the algorithm.</p>
<p>This is a batched version that factors batchCount M-by-N matrices in parallel. dA, ipiv, and info become arrays with one entry per matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>INTEGER The number of rows of each matrix A. M &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>INTEGER The number of columns of each matrix A. N &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dA_array</td><td>Array of pointers, dimension (batchCount). Each is a REAL array on the GPU, dimension (LDDA,N). On entry, each pointer is an M-by-N matrix to be factored. On exit, the factors L and U from the factorization A = P*L*U; the unit diagonal elements of L are not stored.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldda</td><td>INTEGER The leading dimension of each array A. LDDA &gt;= max(1,M).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ipiv_array</td><td>Array of pointers, dimension (batchCount), for corresponding matrices. Each is an INTEGER array, dimension (min(M,N)) The pivot indices; for 1 &lt;= i &lt;= min(M,N), row i of the matrix was interchanged with row IPIV(i).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info_array</td><td>Array of INTEGERs, dimension (batchCount), for corresponding matrices.<ul>
<li>= 0: successful exit</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value or another error occured, such as memory allocation failed.</li>
<li>&gt; 0: if INFO = i, U(i,i) is exactly zero. The factorization has been completed, but the factor U is exactly singular, and division by zero will occur if it is used to solve a system of equations.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">batchCount</td><td>INTEGER The number of matrices to operate on.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>magma_queue_t Queue to execute in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad535e3c1b5069535d3caf9483b712625" name="gad535e3c1b5069535d3caf9483b712625"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad535e3c1b5069535d3caf9483b712625">&#9670;&#160;</a></span>magma_sgetrf_recpanel_batched()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_sgetrf_recpanel_batched </td>
          <td>(</td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>min_recpnb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float **&#160;</td>
          <td class="paramname"><em>dA_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ai</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>aj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t **&#160;</td>
          <td class="paramname"><em>dipiv_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t **&#160;</td>
          <td class="paramname"><em>dpivinfo_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>gbstep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>batchCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmagma__queue.html">magma_queue_t</a>&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an internal routine that might have many assumption. </p>
<p>Documentation is not fully completed</p>
<p>SGETRF_PANEL computes an LU factorization of a general M-by-N matrix A using partial pivoting with row interchanges.</p>
<p>The factorization has the form A = P * L * U where P is a permutation matrix, L is lower triangular with unit diagonal elements (lower trapezoidal if m &gt; n), and U is upper triangular (upper trapezoidal if m &lt; n).</p>
<p>This is the right-looking Level 3 BLAS version of the algorithm.</p>
<p>This is a batched version that factors batchCount M-by-N matrices in parallel. dA, ipiv, and info become arrays with one entry per matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>INTEGER The number of rows of each matrix A. M &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>INTEGER The number of columns of each matrix A. N &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">min_recpnb</td><td>INTEGER. Internal use. The recursive nb</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dA_array</td><td>Array of pointers, dimension (batchCount). Each is a REAL array on the GPU, dimension (LDDA,N). On entry, each pointer is an M-by-N matrix to be factored. On exit, the factors L and U from the factorization A = P*L*U; the unit diagonal elements of L are not stored.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ai</td><td>INTEGER Row offset for A.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aj</td><td>INTEGER Column offset for A.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldda</td><td>INTEGER The leading dimension of each array A. LDDA &gt;= max(1,M).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dipiv_array</td><td>Array of pointers, dimension (batchCount), for corresponding matrices. Each is an INTEGER array, dimension (min(M,N)) The pivot indices; for 1 &lt;= i &lt;= min(M,N), row i of the matrix was interchanged with row IPIV(i).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dpivinfo_array</td><td>Array of pointers, dimension (batchCount), for internal use.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info_array</td><td>Array of INTEGERs, dimension (batchCount), for corresponding matrices.<ul>
<li>= 0: successful exit</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value or another error occured, such as memory allocation failed.</li>
<li>&gt; 0: if INFO = i, U(i,i) is exactly zero. The factorization has been completed, but the factor U is exactly singular, and division by zero will occur if it is used to solve a system of equations.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gbstep</td><td>INTEGER internal use.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">batchCount</td><td>INTEGER The number of matrices to operate on.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>magma_queue_t Queue to execute in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2aeef839ebc3619efc804a667fe97b2b" name="ga2aeef839ebc3619efc804a667fe97b2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2aeef839ebc3619efc804a667fe97b2b">&#9670;&#160;</a></span>magma_sgetrf_recpanel_native()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_sgetrf_recpanel_native </td>
          <td>(</td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>recnb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloat_ptr&#160;</td>
          <td class="paramname"><em>dA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>dipiv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>dipivinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>dinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>gbstep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_event_t&#160;</td>
          <td class="paramname"><em>events</em>[2], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmagma__queue.html">magma_queue_t</a>&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmagma__queue.html">magma_queue_t</a>&#160;</td>
          <td class="paramname"><em>update_queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an internal routine. </p>
<p>SGETRF_PANEL computes an LU factorization of a general M-by-N matrix A using partial pivoting with row interchanges.</p>
<p>The factorization has the form A = P * L * U where P is a permutation matrix, L is lower triangular with unit diagonal elements (lower trapezoidal if m &gt; n), and U is upper triangular (upper trapezoidal if m &lt; n).</p>
<p>This is the right-looking Level 3 BLAS version of the algorithm.</p>
<p>This is a GPU-only routine. The host CPU is not used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>INTEGER The number of rows the matrix A. M &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>INTEGER The number of columns the matrix A. N &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dA</td><td>A REAL array on the GPU, dimension (LDDA,N). On entry, an M-by-N matrix to be factored. On exit, the factors L and U from the factorization A = P*L*U; the unit diagonal elements of L are not stored.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldda</td><td>INTEGER The leading dimension of A. LDDA &gt;= max(1,M).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dipiv</td><td>An INTEGER array, dimension (min(M,N)) The pivot indices; for 1 &lt;= i &lt;= min(M,N), row i of the matrix was interchanged with row IPIV(i).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dipivinfo</td><td>An INTEGER array, for internal use.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dinfo</td><td>INTEGER, stored on the GPU<ul>
<li>= 0: successful exit</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value or another error occured, such as memory allocation failed.</li>
<li>&gt; 0: if INFO = i, U(i,i) is exactly zero. The factorization has been completed, but the factor U is exactly singular, and division by zero will occur if it is used to solve a system of equations.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gbstep</td><td>INTEGER internal use.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queues</td><td>Array of magma_queue_t, size 2 Queues to execute in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga42ec86647df5bb6554b4d7365c4689b9" name="ga42ec86647df5bb6554b4d7365c4689b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga42ec86647df5bb6554b4d7365c4689b9">&#9670;&#160;</a></span>magma_sgetrf_vbatched_max_nocheck_work()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_sgetrf_vbatched_max_nocheck_work </td>
          <td>(</td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>max_m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>max_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>max_minmn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>max_mxn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float **&#160;</td>
          <td class="paramname"><em>dA_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>ldda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t **&#160;</td>
          <td class="paramname"><em>dipiv_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>batchCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmagma__queue.html">magma_queue_t</a>&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SGETRF computes an LU factorization of a general M-by-N matrix A using partial pivoting with row interchanges. </p>
<p>The factorization has the form A = P * L * U where P is a permutation matrix, L is lower triangular with unit diagonal elements (lower trapezoidal if m &gt; n), and U is upper triangular (upper trapezoidal if m &lt; n).</p>
<p>This is the right-looking Level 3 BLAS version of the algorithm.</p>
<p>This is the variable-size batched version, which factors batchCount matrices of different sizes in parallel. Each matrix is assumed to have its own size and leading dimension.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>Array of INTEGERs on the GPU, dimension (batchCount) Each is the number of rows of each matrix A. M[i] &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>Array of INTEGERs on the GPU, dimension (batchCount) Each is the number of columns of each matrix A. N[i] &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">MAX_M</td><td>INTEGER The maximum number of rows across the batch</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">MAX_N</td><td>INTEGER The maximum number of columns across the batch</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">MAX_MINMN</td><td>INTEGER The maximum value of min(Mi, Ni) for i = 1, 2, ..., batchCount</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">MAX_MxN</td><td>INTEGER The maximum value of the product (Mi x Ni) for i = 1, 2, ..., batchCount</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dA_array</td><td>Array of pointers on the GPU, dimension (batchCount). Each is a REAL array on the GPU, dimension (LDDA[i],N[i]). On entry, each pointer is an M[i]-by-N[i] matrix to be factored. On exit, the factors L and U from the factorization A = P*L*U; the unit diagonal elements of L are not stored.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldda</td><td>Array of INTEGERs on the GPU Each is the leading dimension of each array A. LDDA[i] &gt;= max(1,M[i]).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dipiv_array</td><td>Array of pointers, dimension (batchCount), for corresponding matrices. Each is an INTEGER array, dimension (min(M[i],N[i])) The pivot indices; for 1 &lt;= p &lt;= min(M[i],N[i]), row p of the matrix was interchanged with row IPIV(p).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info_array</td><td>Array of INTEGERs, dimension (batchCount), for corresponding matrices.<ul>
<li>= 0: successful exit</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value or another error occured, such as memory allocation failed.</li>
<li>&gt; 0: if INFO = i, U(i,i) is exactly zero. The factorization has been completed, but the factor U is exactly singular, and division by zero will occur if it is used to solve a system of equations.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">WORK</td><td>VOID pointer A workspace of size LWORK[0]</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">LWORK</td><td>INTEGER pointer If lwork[0] &lt; 0, a workspace query is assumed, and lwork[0] is overwritten by the required workspace size in bytes. Otherwise, lwork[0] is the size of work</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">batchCount</td><td>INTEGER The number of matrices to operate on.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>magma_queue_t Queue to execute in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafe8d59d3ca0fde9366bd671adc245198" name="gafe8d59d3ca0fde9366bd671adc245198"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe8d59d3ca0fde9366bd671adc245198">&#9670;&#160;</a></span>magma_sgetrf_vbatched()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_sgetrf_vbatched </td>
          <td>(</td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float **&#160;</td>
          <td class="paramname"><em>dA_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>ldda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t **&#160;</td>
          <td class="paramname"><em>dipiv_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>batchCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmagma__queue.html">magma_queue_t</a>&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SGETRF computes an LU factorization of a general M-by-N matrix A using partial pivoting with row interchanges. </p>
<p>The factorization has the form A = P * L * U where P is a permutation matrix, L is lower triangular with unit diagonal elements (lower trapezoidal if m &gt; n), and U is upper triangular (upper trapezoidal if m &lt; n).</p>
<p>This is the right-looking Level 3 BLAS version of the algorithm.</p>
<p>This is the variable-size batched version, which factors batchCount matrices of different sizes in parallel. Each matrix is assumed to have its own size and leading dimension.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>Array of INTEGERs on the GPU, dimension (batchCount) Each is the number of rows of each matrix A. M[i] &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>Array of INTEGERs on the GPU, dimension (batchCount) Each is the number of columns of each matrix A. N[i] &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dA_array</td><td>Array of pointers on the GPU, dimension (batchCount). Each is a REAL array on the GPU, dimension (LDDA[i],N[i]). On entry, each pointer is an M[i]-by-N[i] matrix to be factored. On exit, the factors L and U from the factorization A = P*L*U; the unit diagonal elements of L are not stored.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldda</td><td>Array of INTEGERs on the GPU Each is the leading dimension of each array A. LDDA[i] &gt;= max(1,M[i]).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dipiv_array</td><td>Array of pointers, dimension (batchCount), for corresponding matrices. Each is an INTEGER array, dimension (min(M[i],N[i])) The pivot indices; for 1 &lt;= p &lt;= min(M[i],N[i]), row p of the matrix was interchanged with row IPIV(p).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info_array</td><td>Array of INTEGERs, dimension (batchCount), for corresponding matrices.<ul>
<li>= 0: successful exit</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value or another error occured, such as memory allocation failed.</li>
<li>&gt; 0: if INFO = i, U(i,i) is exactly zero. The factorization has been completed, but the factor U is exactly singular, and division by zero will occur if it is used to solve a system of equations.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">batchCount</td><td>INTEGER The number of matrices to operate on.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>magma_queue_t Queue to execute in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga86255031910bc4e5995081cb4e989b84" name="ga86255031910bc4e5995081cb4e989b84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga86255031910bc4e5995081cb4e989b84">&#9670;&#160;</a></span>magma_zgbsv_batched_work()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_zgbsv_batched_work </td>
          <td>(</td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>kl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ku</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>nrhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaDoubleComplex **&#160;</td>
          <td class="paramname"><em>dA_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t **&#160;</td>
          <td class="paramname"><em>dipiv_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaDoubleComplex **&#160;</td>
          <td class="paramname"><em>dB_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lddb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>device_work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>batchCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmagma__queue.html">magma_queue_t</a>&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ZGBSV computes the solution to a system of linear equations A * X = B, where A is a band matrix of order N with KL subdiagonals and KU superdiagonals, and X and B are N-by-NRHS matrices. </p>
<p>The LU decomposition with partial pivoting and row interchanges is used to factor A as A = L * U, where L is a product of permutation and unit lower triangular matrices with KL subdiagonals, and U is upper triangular with KL+KU superdiagonals. The factored form of A is then used to solve the system of equations A * X = B.</p>
<p>This is the batched version of the routine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>INTEGER The order of the matrix A. n &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kl</td><td>INTEGER The number of subdiagonals within the band of A. KL &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ku</td><td>INTEGER The number of superdiagonals within the band of A. KL &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nrhs</td><td>INTEGER The number of right hand sides, i.e., the number of columns of the matrix B. NRHS &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dA_array</td><td>Array of pointers, dimension (batchCount). Each contains the details of the LU factorization of the band matrix A, as computed by ZGBTRF. U is stored as an upper triangular band matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and the multipliers used during the factorization are stored in rows KL+KU+2 to 2*KL+KU+1.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldda</td><td>INTEGER The leading dimension of each array A. LDDA &gt;= (2*KL+KU+1).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dipiv_array</td><td>Array of pointers, dimension (batchCount), for corresponding matrices. Each is an INTEGER array, dimension (min(M,N)) The pivot indices; for 1 &lt;= i &lt;= min(M,N), row i of the matrix was interchanged with row IPIV(i).</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dB_array</td><td>Array of pointers, dimension (batchCount). Each is a COMPLEX*16 array, dimension (LDB,NRHS) On entry, the right hand side matrix B. On exit, the solution matrix X.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lddb</td><td>INTEGER The leading dimension of each array B. LDDB &gt;= max(1, N).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info_array</td><td>Array of INTEGERs, dimension (batchCount), for corresponding matrices.<ul>
<li>= 0: successful exit</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value or another error occured, such as memory allocation failed. &gt; 0: if INFO = i, U(i,i) is exactly zero. The factorization has been completed, but the factor U is exactly singular, and the solution has not been computed.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">device_work</td><td>Workspace, allocated on device memory.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lwork</td><td>INTEGER pointer The size of the workspace (device_work) in bytes<ul>
<li>lwork[0] &lt; 0: a workspace query is assumed, the routine calculates the required amount of workspace and returns it in lwork. The workspace is not referenced, and no computation is performed.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>lwork[0] &gt;= 0: the routine assumes that the user has provided a workspace with the size in lwork.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">batchCount</td><td>INTEGER The number of matrices to operate on.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>magma_queue_t Queue to execute in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga921d0451be70ab811ef11d19c6b9bb7e" name="ga921d0451be70ab811ef11d19c6b9bb7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga921d0451be70ab811ef11d19c6b9bb7e">&#9670;&#160;</a></span>magma_zgbsv_batched()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_zgbsv_batched </td>
          <td>(</td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>kl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ku</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>nrhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaDoubleComplex **&#160;</td>
          <td class="paramname"><em>dA_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t **&#160;</td>
          <td class="paramname"><em>dipiv_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaDoubleComplex **&#160;</td>
          <td class="paramname"><em>dB_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lddb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>batchCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmagma__queue.html">magma_queue_t</a>&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ZGBSV computes the solution to a system of linear equations A * X = B, where A is a band matrix of order N with KL subdiagonals and KU superdiagonals, and X and B are N-by-NRHS matrices. </p>
<p>The LU decomposition with partial pivoting and row interchanges is used to factor A as A = L * U, where L is a product of permutation and unit lower triangular matrices with KL subdiagonals, and U is upper triangular with KL+KU superdiagonals. The factored form of A is then used to solve the system of equations A * X = B.</p>
<p>This is the batched version of the routine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>INTEGER The order of the matrix A. n &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kl</td><td>INTEGER The number of subdiagonals within the band of A. KL &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ku</td><td>INTEGER The number of superdiagonals within the band of A. KL &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nrhs</td><td>INTEGER The number of right hand sides, i.e., the number of columns of the matrix B. NRHS &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dA_array</td><td>Array of pointers, dimension (batchCount). Each contains the details of the LU factorization of the band matrix A, as computed by ZGBTRF. U is stored as an upper triangular band matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and the multipliers used during the factorization are stored in rows KL+KU+2 to 2*KL+KU+1.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldda</td><td>INTEGER The leading dimension of each array A. LDDA &gt;= (2*KL+KU+1).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dipiv_array</td><td>Array of pointers, dimension (batchCount), for corresponding matrices. Each is an INTEGER array, dimension (min(M,N)) The pivot indices; for 1 &lt;= i &lt;= min(M,N), row i of the matrix was interchanged with row IPIV(i).</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dB_array</td><td>Array of pointers, dimension (batchCount). Each is a COMPLEX*16 array, dimension (LDB,NRHS) On entry, the right hand side matrix B. On exit, the solution matrix X.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lddb</td><td>INTEGER The leading dimension of each array B. LDDB &gt;= max(1, N).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info_array</td><td>Array of INTEGERs, dimension (batchCount), for corresponding matrices.<ul>
<li>= 0: successful exit</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value or another error occured, such as memory allocation failed.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">batchCount</td><td>INTEGER The number of matrices to operate on.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>magma_queue_t Queue to execute in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae87b0262667fc0a402057b59f87116c4" name="gae87b0262667fc0a402057b59f87116c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae87b0262667fc0a402057b59f87116c4">&#9670;&#160;</a></span>magma_zgbtrf_batched_work()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_zgbtrf_batched_work </td>
          <td>(</td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>kl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ku</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaDoubleComplex **&#160;</td>
          <td class="paramname"><em>dAB_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lddab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t **&#160;</td>
          <td class="paramname"><em>dipiv_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>device_work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>batchCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmagma__queue.html">magma_queue_t</a>&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ZGBTRF computes an LU factorization of a complex m-by-n band matrix AB using partial pivoting with row interchanges. </p>
<p>This is a batched version that factors <code>batchCount</code> M-by-N matrices in parallel. dAB, dipiv, and info become arrays with one entry per matrix.</p>
<p>The band storage scheme is illustrated by the following example, when M = N = 6, KL = 2, KU = 1:</p>
<p>On entry: On exit: </p><pre class="fragment">    *    *    +    +    +       *    *    *   u14  u25  u36
    *    +    +    +    +       *    *   u13  u24  u35  u46
   a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56
</pre><p> a11 a22 a33 a44 a55 a66 u11 u22 u33 u44 u55 u66 a21 a32 a43 a54 a65 * m21 m32 m43 m54 m65 * a31 a42 a53 a64 * * m31 m42 m53 m64 * *</p>
<p>Note that this behavior is a little different from the standard LAPACK routine. Array elements marked * are not read by the routine, but may be zeroed out after completion. Elements marked + need not be set on entry, but are required by the routine to store elements of U because of fill-in resulting from the row interchanges.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>INTEGER The number of rows of each matrix A. M &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>INTEGER The number of columns of each matrix A. N &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kl</td><td>INTEGER The number of subdiagonals within the band of A. KL &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ku</td><td>INTEGER The number of superdiagonals within the band of A. KL &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dAB_array</td><td>Array of pointers, dimension (batchCount). Each is a COMPLEX_16 array on the GPU, dimension (LDAB,N) On entry, the matrix A in band storage, in rows KL+1 to 2*KL+KU+1; rows 1 to KL of the array need not be set. The j-th column of A is stored in the j-th column of the array AB as follows: AB(kl+ku+1+i-j,j) = A(i,j) for max(1,j-ku)&lt;=i&lt;=min(m,j+kl)</td></tr>
  </table>
  </dd>
</dl>
<p>On exit, details of the factorization: U is stored as an upper triangular band matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and the multipliers used during the factorization are stored in rows KL+KU+2 to 2*KL+KU+1. See above for details about the band storage.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lddab</td><td>INTEGER The leading dimension of each array AB. LDDAB &gt;= (2*KL+KU+1).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dipiv_array</td><td>Array of pointers, dimension (batchCount), for corresponding matrices. Each is an INTEGER array, dimension (min(M,N)) The pivot indices; for 1 &lt;= i &lt;= min(M,N), row i of the matrix was interchanged with row IPIV(i).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info_array</td><td>Array of INTEGERs, dimension (batchCount), for corresponding matrices.<ul>
<li>= 0: successful exit</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value or another error occured, such as memory allocation failed.</li>
<li>&gt; 0: if INFO = i, U(i,i) is exactly zero. The factorization has been completed, but the factor U is exactly singular, and division by zero will occur if it is used to solve a system of equations.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">device_work</td><td>Workspace, allocated on device memory</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lwork</td><td>INTEGER pointer The size of the workspace (device_work) in bytes<ul>
<li>lwork[0] &lt; 0: a workspace query is assumed, the routine calculates the required amount of workspace and returns it in lwork. The workspace is not referenced, and no factorization is performed.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>lwork[0] &gt;= 0: the routine assumes that the user has provided a workspace with the size in lwork.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">batchCount</td><td>INTEGER The number of matrices to operate on.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>magma_queue_t Queue to execute in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab6fc579f5d372dd13ed6ef863b369bd5" name="gab6fc579f5d372dd13ed6ef863b369bd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab6fc579f5d372dd13ed6ef863b369bd5">&#9670;&#160;</a></span>magma_zgbtrf_batched()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_zgbtrf_batched </td>
          <td>(</td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>kl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ku</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaDoubleComplex **&#160;</td>
          <td class="paramname"><em>dAB_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lddab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t **&#160;</td>
          <td class="paramname"><em>dipiv_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>batchCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmagma__queue.html">magma_queue_t</a>&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ZGBTRF computes an LU factorization of a COMPLEX m-by-n band matrix A using partial pivoting with row interchanges. </p>
<p>This is the batched version of the algorithm, which performs the factorization on a batch of matrices with the same size and lower/upper bandwidths.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>INTEGER The number of rows of the matrix A. M &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>INTEGER The number of columns of the matrix A. N &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">KL</td><td>INTEGER The number of subdiagonals within the band of A. KL &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">KU</td><td>INTEGER The number of superdiagonals within the band of A. KU &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dAB_array</td><td>Array of pointers, dimension (batchCount). Each is a COMPLEX_16 array, dimension (LDDAB,N) On entry, the matrix AB in band storage, in rows KL+1 to 2*KL+KU+1; rows 1 to KL of the array need not be set. The j-th column of A is stored in the j-th column of the array AB as follows: AB(kl+ku+1+i-j,j) = A(i,j) for max(1,j-ku)&lt;=i&lt;=min(m,j+kl)</td></tr>
  </table>
  </dd>
</dl>
<p>On exit, details of the factorization: U is stored as an upper triangular band matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and the multipliers used during the factorization are stored in rows KL+KU+2 to 2*KL+KU+1. See below for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">LDDAB</td><td>INTEGER The leading dimension of the array AB. LDAB &gt;= 2*KL+KU+1.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dIPIV_array</td><td>Array of pointers, dimension (batchCount). Each is an INTEGER array, dimension (min(M,N)) The pivot indices; for 1 &lt;= i &lt;= min(M,N), row i of the matrix was interchanged with row IPIV(i).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dINFO_array</td><td>INTEGER array, dimension (batchCount) Each is the INFO output for a given matrix = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value &gt; 0: if INFO = +i, U(i,i) is exactly zero. The factorization has been completed, but the factor U is exactly singular, and division by zero will occur if it is used to solve a system of equations.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">batchCount</td><td>INTEGER The number of matrices to operate on.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>magma_queue_t Queue to execute in.</td></tr>
  </table>
  </dd>
</dl>
<h1><a class="anchor" id="autotoc_md241"></a>
Further Details</h1>
<p>The band storage scheme is illustrated by the following example, when M = N = 6, KL = 2, KU = 1:</p>
<p>On entry: On exit: </p><pre class="fragment">     *    *    +    +    +       *    *    *   u14  u25  u36
     *    +    +    +    +       *    *   u13  u24  u35  u46
    a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56
</pre><p> a11 a22 a33 a44 a55 a66 u11 u22 u33 u44 u55 u66 a21 a32 a43 a54 a65 * m21 m32 m43 m54 m65 * a31 a42 a53 a64 * * m31 m42 m53 m64 * *</p>
<p>Array elements marked * are not used by the routine; elements marked</p><ul>
<li>need not be set on entry, but are required by the routine to store elements of U because of fill-in resulting from the row interchanges. </li>
</ul>

</div>
</div>
<a id="gafdf9c7faa96f566e463dfc4bf7cca2de" name="gafdf9c7faa96f566e463dfc4bf7cca2de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafdf9c7faa96f566e463dfc4bf7cca2de">&#9670;&#160;</a></span>magma_zgbtrs_batched()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_zgbtrs_batched </td>
          <td>(</td>
          <td class="paramtype">magma_trans_t&#160;</td>
          <td class="paramname"><em>transA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>kl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ku</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>nrhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaDoubleComplex **&#160;</td>
          <td class="paramname"><em>dA_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t **&#160;</td>
          <td class="paramname"><em>dipiv_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaDoubleComplex **&#160;</td>
          <td class="paramname"><em>dB_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lddb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>batchCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmagma__queue.html">magma_queue_t</a>&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ZGBTRS solves a system of linear equations A * X = B, A**T * X = B, or A**H * X = B with a general band matrix A using the LU factorization computed by ZGBTRF. </p>
<p>This is the batched version of the routine. Currently, only (A * X = B) is supported (no-trans only)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">transA</td><td>magma_trans_t Specifies the form of the system of equations. Currently, only MagnaNoTrans is supported (A*X = B)</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>INTEGER The order of the matrix A. n &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kl</td><td>INTEGER The number of subdiagonals within the band of A. KL &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ku</td><td>INTEGER The number of superdiagonals within the band of A. KL &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nrhs</td><td>INTEGER The number of right hand sides, i.e., the number of columns of the matrix B. NRHS &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dA_array</td><td>Array of pointers, dimension (batchCount). Each contains the details of the LU factorization of the band matrix A, as computed by ZGBTRF. U is stored as an upper triangular band matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and the multipliers used during the factorization are stored in rows KL+KU+2 to 2*KL+KU+1.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldda</td><td>INTEGER The leading dimension of each array A. LDDA &gt;= (2*KL+KU+1).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dipiv_array</td><td>Array of pointers, dimension (batchCount), for corresponding matrices. Each is an INTEGER array, dimension (min(M,N)) The pivot indices; for 1 &lt;= i &lt;= min(M,N), row i of the matrix was interchanged with row IPIV(i).</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dB_array</td><td>Array of pointers, dimension (batchCount). Each is a COMPLEX*16 array, dimension (LDB,NRHS) On entry, the right hand side matrix B. On exit, the solution matrix X.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lddb</td><td>INTEGER The leading dimension of each array B. LDDB &gt;= max(1, N).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info_array</td><td>Array of INTEGERs, dimension (batchCount), for corresponding matrices.<ul>
<li>= 0: successful exit</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value or another error occured, such as memory allocation failed.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">batchCount</td><td>INTEGER The number of matrices to operate on.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>magma_queue_t Queue to execute in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabef89818dcb7947c49f4440b82b2f0b7" name="gabef89818dcb7947c49f4440b82b2f0b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabef89818dcb7947c49f4440b82b2f0b7">&#9670;&#160;</a></span>magma_zgetrf_batched()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_zgetrf_batched </td>
          <td>(</td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaDoubleComplex **&#160;</td>
          <td class="paramname"><em>dA_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t **&#160;</td>
          <td class="paramname"><em>ipiv_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>batchCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmagma__queue.html">magma_queue_t</a>&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ZGETRF computes an LU factorization of a general M-by-N matrix A using partial pivoting with row interchanges. </p>
<p>The factorization has the form A = P * L * U where P is a permutation matrix, L is lower triangular with unit diagonal elements (lower trapezoidal if m &gt; n), and U is upper triangular (upper trapezoidal if m &lt; n).</p>
<p>This is the right-looking Level 3 BLAS version of the algorithm.</p>
<p>This is a batched version that factors batchCount M-by-N matrices in parallel. dA, ipiv, and info become arrays with one entry per matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>INTEGER The number of rows of each matrix A. M &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>INTEGER The number of columns of each matrix A. N &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dA_array</td><td>Array of pointers, dimension (batchCount). Each is a COMPLEX_16 array on the GPU, dimension (LDDA,N). On entry, each pointer is an M-by-N matrix to be factored. On exit, the factors L and U from the factorization A = P*L*U; the unit diagonal elements of L are not stored.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldda</td><td>INTEGER The leading dimension of each array A. LDDA &gt;= max(1,M).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ipiv_array</td><td>Array of pointers, dimension (batchCount), for corresponding matrices. Each is an INTEGER array, dimension (min(M,N)) The pivot indices; for 1 &lt;= i &lt;= min(M,N), row i of the matrix was interchanged with row IPIV(i).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info_array</td><td>Array of INTEGERs, dimension (batchCount), for corresponding matrices.<ul>
<li>= 0: successful exit</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value or another error occured, such as memory allocation failed.</li>
<li>&gt; 0: if INFO = i, U(i,i) is exactly zero. The factorization has been completed, but the factor U is exactly singular, and division by zero will occur if it is used to solve a system of equations.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">batchCount</td><td>INTEGER The number of matrices to operate on.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>magma_queue_t Queue to execute in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8f5648a68cb0c5208acaa9f6f3f4befe" name="ga8f5648a68cb0c5208acaa9f6f3f4befe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8f5648a68cb0c5208acaa9f6f3f4befe">&#9670;&#160;</a></span>magma_zgetrf_recpanel_batched()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_zgetrf_recpanel_batched </td>
          <td>(</td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>min_recpnb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaDoubleComplex **&#160;</td>
          <td class="paramname"><em>dA_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ai</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>aj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t **&#160;</td>
          <td class="paramname"><em>dipiv_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t **&#160;</td>
          <td class="paramname"><em>dpivinfo_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>gbstep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>batchCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmagma__queue.html">magma_queue_t</a>&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an internal routine that might have many assumption. </p>
<p>Documentation is not fully completed</p>
<p>ZGETRF_PANEL computes an LU factorization of a general M-by-N matrix A using partial pivoting with row interchanges.</p>
<p>The factorization has the form A = P * L * U where P is a permutation matrix, L is lower triangular with unit diagonal elements (lower trapezoidal if m &gt; n), and U is upper triangular (upper trapezoidal if m &lt; n).</p>
<p>This is the right-looking Level 3 BLAS version of the algorithm.</p>
<p>This is a batched version that factors batchCount M-by-N matrices in parallel. dA, ipiv, and info become arrays with one entry per matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>INTEGER The number of rows of each matrix A. M &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>INTEGER The number of columns of each matrix A. N &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">min_recpnb</td><td>INTEGER. Internal use. The recursive nb</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dA_array</td><td>Array of pointers, dimension (batchCount). Each is a COMPLEX_16 array on the GPU, dimension (LDDA,N). On entry, each pointer is an M-by-N matrix to be factored. On exit, the factors L and U from the factorization A = P*L*U; the unit diagonal elements of L are not stored.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ai</td><td>INTEGER Row offset for A.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aj</td><td>INTEGER Column offset for A.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldda</td><td>INTEGER The leading dimension of each array A. LDDA &gt;= max(1,M).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dipiv_array</td><td>Array of pointers, dimension (batchCount), for corresponding matrices. Each is an INTEGER array, dimension (min(M,N)) The pivot indices; for 1 &lt;= i &lt;= min(M,N), row i of the matrix was interchanged with row IPIV(i).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dpivinfo_array</td><td>Array of pointers, dimension (batchCount), for internal use.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info_array</td><td>Array of INTEGERs, dimension (batchCount), for corresponding matrices.<ul>
<li>= 0: successful exit</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value or another error occured, such as memory allocation failed.</li>
<li>&gt; 0: if INFO = i, U(i,i) is exactly zero. The factorization has been completed, but the factor U is exactly singular, and division by zero will occur if it is used to solve a system of equations.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gbstep</td><td>INTEGER internal use.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">batchCount</td><td>INTEGER The number of matrices to operate on.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>magma_queue_t Queue to execute in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8f464db9d5e8060c94180a864d6688b1" name="ga8f464db9d5e8060c94180a864d6688b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8f464db9d5e8060c94180a864d6688b1">&#9670;&#160;</a></span>magma_zgetrf_recpanel_native()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_zgetrf_recpanel_native </td>
          <td>(</td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>recnb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaDoubleComplex_ptr&#160;</td>
          <td class="paramname"><em>dA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>dipiv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>dipivinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>dinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>gbstep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_event_t&#160;</td>
          <td class="paramname"><em>events</em>[2], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmagma__queue.html">magma_queue_t</a>&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmagma__queue.html">magma_queue_t</a>&#160;</td>
          <td class="paramname"><em>update_queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an internal routine. </p>
<p>ZGETRF_PANEL computes an LU factorization of a general M-by-N matrix A using partial pivoting with row interchanges.</p>
<p>The factorization has the form A = P * L * U where P is a permutation matrix, L is lower triangular with unit diagonal elements (lower trapezoidal if m &gt; n), and U is upper triangular (upper trapezoidal if m &lt; n).</p>
<p>This is the right-looking Level 3 BLAS version of the algorithm.</p>
<p>This is a GPU-only routine. The host CPU is not used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>INTEGER The number of rows the matrix A. M &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>INTEGER The number of columns the matrix A. N &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dA</td><td>A COMPLEX_16 array on the GPU, dimension (LDDA,N). On entry, an M-by-N matrix to be factored. On exit, the factors L and U from the factorization A = P*L*U; the unit diagonal elements of L are not stored.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldda</td><td>INTEGER The leading dimension of A. LDDA &gt;= max(1,M).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dipiv</td><td>An INTEGER array, dimension (min(M,N)) The pivot indices; for 1 &lt;= i &lt;= min(M,N), row i of the matrix was interchanged with row IPIV(i).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dipivinfo</td><td>An INTEGER array, for internal use.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dinfo</td><td>INTEGER, stored on the GPU<ul>
<li>= 0: successful exit</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value or another error occured, such as memory allocation failed.</li>
<li>&gt; 0: if INFO = i, U(i,i) is exactly zero. The factorization has been completed, but the factor U is exactly singular, and division by zero will occur if it is used to solve a system of equations.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gbstep</td><td>INTEGER internal use.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queues</td><td>Array of magma_queue_t, size 2 Queues to execute in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga70a93ca906d74f3d1a865046ae26a5e7" name="ga70a93ca906d74f3d1a865046ae26a5e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga70a93ca906d74f3d1a865046ae26a5e7">&#9670;&#160;</a></span>magma_zgetrf_vbatched_max_nocheck_work()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_zgetrf_vbatched_max_nocheck_work </td>
          <td>(</td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>max_m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>max_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>max_minmn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>max_mxn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaDoubleComplex **&#160;</td>
          <td class="paramname"><em>dA_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>ldda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t **&#160;</td>
          <td class="paramname"><em>dipiv_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>batchCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmagma__queue.html">magma_queue_t</a>&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ZGETRF computes an LU factorization of a general M-by-N matrix A using partial pivoting with row interchanges. </p>
<p>The factorization has the form A = P * L * U where P is a permutation matrix, L is lower triangular with unit diagonal elements (lower trapezoidal if m &gt; n), and U is upper triangular (upper trapezoidal if m &lt; n).</p>
<p>This is the right-looking Level 3 BLAS version of the algorithm.</p>
<p>This is the variable-size batched version, which factors batchCount matrices of different sizes in parallel. Each matrix is assumed to have its own size and leading dimension.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>Array of INTEGERs on the GPU, dimension (batchCount) Each is the number of rows of each matrix A. M[i] &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>Array of INTEGERs on the GPU, dimension (batchCount) Each is the number of columns of each matrix A. N[i] &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">MAX_M</td><td>INTEGER The maximum number of rows across the batch</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">MAX_N</td><td>INTEGER The maximum number of columns across the batch</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">MAX_MINMN</td><td>INTEGER The maximum value of min(Mi, Ni) for i = 1, 2, ..., batchCount</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">MAX_MxN</td><td>INTEGER The maximum value of the product (Mi x Ni) for i = 1, 2, ..., batchCount</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dA_array</td><td>Array of pointers on the GPU, dimension (batchCount). Each is a COMPLEX_16 array on the GPU, dimension (LDDA[i],N[i]). On entry, each pointer is an M[i]-by-N[i] matrix to be factored. On exit, the factors L and U from the factorization A = P*L*U; the unit diagonal elements of L are not stored.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldda</td><td>Array of INTEGERs on the GPU Each is the leading dimension of each array A. LDDA[i] &gt;= max(1,M[i]).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dipiv_array</td><td>Array of pointers, dimension (batchCount), for corresponding matrices. Each is an INTEGER array, dimension (min(M[i],N[i])) The pivot indices; for 1 &lt;= p &lt;= min(M[i],N[i]), row p of the matrix was interchanged with row IPIV(p).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info_array</td><td>Array of INTEGERs, dimension (batchCount), for corresponding matrices.<ul>
<li>= 0: successful exit</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value or another error occured, such as memory allocation failed.</li>
<li>&gt; 0: if INFO = i, U(i,i) is exactly zero. The factorization has been completed, but the factor U is exactly singular, and division by zero will occur if it is used to solve a system of equations.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">WORK</td><td>VOID pointer A workspace of size LWORK[0]</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">LWORK</td><td>INTEGER pointer If lwork[0] &lt; 0, a workspace query is assumed, and lwork[0] is overwritten by the required workspace size in bytes. Otherwise, lwork[0] is the size of work</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">batchCount</td><td>INTEGER The number of matrices to operate on.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>magma_queue_t Queue to execute in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga721a924bcd11aba71b77c8851d6d5ed6" name="ga721a924bcd11aba71b77c8851d6d5ed6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga721a924bcd11aba71b77c8851d6d5ed6">&#9670;&#160;</a></span>magma_zgetrf_vbatched()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_zgetrf_vbatched </td>
          <td>(</td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaDoubleComplex **&#160;</td>
          <td class="paramname"><em>dA_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>ldda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t **&#160;</td>
          <td class="paramname"><em>dipiv_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>batchCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmagma__queue.html">magma_queue_t</a>&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ZGETRF computes an LU factorization of a general M-by-N matrix A using partial pivoting with row interchanges. </p>
<p>The factorization has the form A = P * L * U where P is a permutation matrix, L is lower triangular with unit diagonal elements (lower trapezoidal if m &gt; n), and U is upper triangular (upper trapezoidal if m &lt; n).</p>
<p>This is the right-looking Level 3 BLAS version of the algorithm.</p>
<p>This is the variable-size batched version, which factors batchCount matrices of different sizes in parallel. Each matrix is assumed to have its own size and leading dimension.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>Array of INTEGERs on the GPU, dimension (batchCount) Each is the number of rows of each matrix A. M[i] &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>Array of INTEGERs on the GPU, dimension (batchCount) Each is the number of columns of each matrix A. N[i] &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dA_array</td><td>Array of pointers on the GPU, dimension (batchCount). Each is a COMPLEX_16 array on the GPU, dimension (LDDA[i],N[i]). On entry, each pointer is an M[i]-by-N[i] matrix to be factored. On exit, the factors L and U from the factorization A = P*L*U; the unit diagonal elements of L are not stored.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldda</td><td>Array of INTEGERs on the GPU Each is the leading dimension of each array A. LDDA[i] &gt;= max(1,M[i]).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dipiv_array</td><td>Array of pointers, dimension (batchCount), for corresponding matrices. Each is an INTEGER array, dimension (min(M[i],N[i])) The pivot indices; for 1 &lt;= p &lt;= min(M[i],N[i]), row p of the matrix was interchanged with row IPIV(p).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info_array</td><td>Array of INTEGERs, dimension (batchCount), for corresponding matrices.<ul>
<li>= 0: successful exit</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value or another error occured, such as memory allocation failed.</li>
<li>&gt; 0: if INFO = i, U(i,i) is exactly zero. The factorization has been completed, but the factor U is exactly singular, and division by zero will occur if it is used to solve a system of equations.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">batchCount</td><td>INTEGER The number of matrices to operate on.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>magma_queue_t Queue to execute in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3247fe35270234d0b56eafd9fb1b4967" name="ga3247fe35270234d0b56eafd9fb1b4967"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3247fe35270234d0b56eafd9fb1b4967">&#9670;&#160;</a></span>magma_cgbsv_batched_fused_sm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_cgbsv_batched_fused_sm </td>
          <td>(</td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>kl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ku</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>nrhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex **&#160;</td>
          <td class="paramname"><em>dA_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t **&#160;</td>
          <td class="paramname"><em>ipiv_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex **&#160;</td>
          <td class="paramname"><em>dB_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lddb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>nthreads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ntcol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>batchCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmagma__queue.html">magma_queue_t</a>&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>CGBSV computes the solution to a system of linear equations A * X = B, where A is a band matrix of order N with KL subdiagonals and KU superdiagonals, and X and B are N-by-NRHS matrices. </p>
<p>The LU decomposition with partial pivoting and row interchanges is used to factor A as A = L * U, where L is a product of permutation and unit lower triangular matrices with KL subdiagonals, and U is upper triangular with KL+KU superdiagonals. The factored form of A is then used to solve the system of equations A * X = B.</p>
<p>This is the batched version of the routine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>INTEGER The order of the matrix A. n &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kl</td><td>INTEGER The number of subdiagonals within the band of A. KL &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ku</td><td>INTEGER The number of superdiagonals within the band of A. KL &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nrhs</td><td>INTEGER The number of right hand sides, i.e., the number of columns of the matrix B. NRHS &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dA_array</td><td>Array of pointers, dimension (batchCount). Each contains the details of the LU factorization of the band matrix A, as computed by CGBTRF. U is stored as an upper triangular band matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and the multipliers used during the factorization are stored in rows KL+KU+2 to 2*KL+KU+1.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldda</td><td>INTEGER The leading dimension of each array A. LDDA &gt;= (2*KL+KU+1).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dipiv_array</td><td>Array of pointers, dimension (batchCount), for corresponding matrices. Each is an INTEGER array, dimension (min(M,N)) The pivot indices; for 1 &lt;= i &lt;= min(M,N), row i of the matrix was interchanged with row IPIV(i).</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dB_array</td><td>Array of pointers, dimension (batchCount). Each is a COMPLEX array, dimension (LDB,NRHS) On entry, the right hand side matrix B. On exit, the solution matrix X.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lddb</td><td>INTEGER The leading dimension of each array B. LDDB &gt;= max(1, N).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info_array</td><td>Array of INTEGERs, dimension (batchCount), for corresponding matrices.<ul>
<li>= 0: successful exit</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value or another error occured, such as memory allocation failed.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nthreads</td><td>INTEGER The number of threads assigned to a single matrix. nthreads &gt;= (KL+1)</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ntcol</td><td>INTEGER The number of concurrent factorizations in a thread-block ntcol &gt;= 1</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">batchCount</td><td>INTEGER The number of matrices to operate on.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>magma_queue_t Queue to execute in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga583108a75225b3136abc6431b151f901" name="ga583108a75225b3136abc6431b151f901"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga583108a75225b3136abc6431b151f901">&#9670;&#160;</a></span>magma_cgbtrf_batched_fused_sm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_cgbtrf_batched_fused_sm </td>
          <td>(</td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>kl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ku</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex **&#160;</td>
          <td class="paramname"><em>dAB_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lddab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t **&#160;</td>
          <td class="paramname"><em>ipiv_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>nthreads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ntcol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>batchCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmagma__queue.html">magma_queue_t</a>&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>CGBTRF computes an LU factorization of a COMPLEX m-by-n band matrix A using partial pivoting with row interchanges. </p>
<p>This is the batched version of the algorithm, which performs the factorization on a batch of matrices with the same size and lower/upper bandwidths.</p>
<p>This routine has shared memory requirements that may exceed the capacity of the GPU. In such a case, the routine exits immediately, returning a negative error code.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>INTEGER The number of rows of the matrix A. M &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>INTEGER The number of columns of the matrix A. N &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">KL</td><td>INTEGER The number of subdiagonals within the band of A. KL &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">KU</td><td>INTEGER The number of superdiagonals within the band of A. KU &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dAB_array</td><td>Array of pointers, dimension (batchCount). Each is a COMPLEX array, dimension (LDDAB,N) On entry, the matrix AB in band storage, in rows KL+1 to 2*KL+KU+1; rows 1 to KL of the array need not be set. The j-th column of A is stored in the j-th column of the array AB as follows: AB(kl+ku+1+i-j,j) = A(i,j) for max(1,j-ku)&lt;=i&lt;=min(m,j+kl)</td></tr>
  </table>
  </dd>
</dl>
<p>On exit, details of the factorization: U is stored as an upper triangular band matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and the multipliers used during the factorization are stored in rows KL+KU+2 to 2*KL+KU+1. See below for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">LDDAB</td><td>INTEGER The leading dimension of the array AB. LDAB &gt;= 2*KL+KU+1.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dIPIV_array</td><td>Array of pointers, dimension (batchCount). Each is an INTEGER array, dimension (min(M,N)) The pivot indices; for 1 &lt;= i &lt;= min(M,N), row i of the matrix was interchanged with row IPIV(i).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dINFO_array</td><td>INTEGER array, dimension (batchCount) Each is the INFO output for a given matrix = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value &gt; 0: if INFO = +i, U(i,i) is exactly zero. The factorization has been completed, but the factor U is exactly singular, and division by zero will occur if it is used to solve a system of equations.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nthreads</td><td>INTEGER The number of threads assigned to a single matrix. nthreads &gt;= (KL+1)</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ntcol</td><td>INTEGER The number of concurrent factorizations in a thread-block ntcol &gt;= 1</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">batchCount</td><td>INTEGER The number of matrices to operate on.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>magma_queue_t Queue to execute in.</td></tr>
  </table>
  </dd>
</dl>
<h2><a class="anchor" id="autotoc_md313"></a>
Further Details</h2>
<p>The band storage scheme is illustrated by the following example, when M = N = 6, KL = 2, KU = 1:</p>
<p>On entry: On exit: </p><pre class="fragment">   *    *    +    +    +       *    *    *   u14  u25  u36
   *    +    +    +    +       *    *   u13  u24  u35  u46
  a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56
</pre><p> a11 a22 a33 a44 a55 a66 u11 u22 u33 u44 u55 u66 a21 a32 a43 a54 a65 * m21 m32 m43 m54 m65 * a31 a42 a53 a64 * * m31 m42 m53 m64 * *</p>
<p>Array elements marked * are not used by the routine, but may be set to zero after completion. Elements marked</p><ul>
<li>need not be set on entry, but are required by the routine to store elements of U because of fill-in resulting from the row interchanges. </li>
</ul>

</div>
</div>
<a id="gaecd534b0b56150f0097139de783f9ff4" name="gaecd534b0b56150f0097139de783f9ff4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaecd534b0b56150f0097139de783f9ff4">&#9670;&#160;</a></span>magma_cgbtrf_batched_sliding_window_loopout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_cgbtrf_batched_sliding_window_loopout </td>
          <td>(</td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>kl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ku</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex **&#160;</td>
          <td class="paramname"><em>dAB_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lddab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t **&#160;</td>
          <td class="paramname"><em>ipiv_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>device_work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>batchCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmagma__queue.html">magma_queue_t</a>&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>CGBTRF computes an LU factorization of a COMPLEX m-by-n band matrix A using partial pivoting with row interchanges. </p>
<p>This is the batched version of the algorithm, which performs the factorization on a batch of matrices with the same size and lower/upper bandwidths.</p>
<p>This routine has shared memory requirements that may exceed the capacity of the GPU. In such a case, the routine exits immediately, returning a negative error code.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>INTEGER The number of rows of the matrix A. M &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>INTEGER The number of columns of the matrix A. N &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">KL</td><td>INTEGER The number of subdiagonals within the band of A. KL &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">KU</td><td>INTEGER The number of superdiagonals within the band of A. KU &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dAB_array</td><td>Array of pointers, dimension (batchCount). Each is a COMPLEX array, dimension (LDDAB,N) On entry, the matrix AB in band storage, in rows KL+1 to 2*KL+KU+1; rows 1 to KL of the array need not be set. The j-th column of A is stored in the j-th column of the array AB as follows: AB(kl+ku+1+i-j,j) = A(i,j) for max(1,j-ku)&lt;=i&lt;=min(m,j+kl)</td></tr>
  </table>
  </dd>
</dl>
<p>On exit, details of the factorization: U is stored as an upper triangular band matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and the multipliers used during the factorization are stored in rows KL+KU+2 to 2*KL+KU+1. See below for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">LDDAB</td><td>INTEGER The leading dimension of the array AB. LDAB &gt;= 2*KL+KU+1.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dIPIV_array</td><td>Array of pointers, dimension (batchCount). Each is an INTEGER array, dimension (min(M,N)) The pivot indices; for 1 &lt;= i &lt;= min(M,N), row i of the matrix was interchanged with row IPIV(i).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dINFO_array</td><td>INTEGER array, dimension (batchCount) Each is the INFO output for a given matrix = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value &gt; 0: if INFO = +i, U(i,i) is exactly zero. The factorization has been completed, but the factor U is exactly singular, and division by zero will occur if it is used to solve a system of equations.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">device_work</td><td>Workspace, allocated on device memory by the user</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lwork</td><td>INTEGER pointer The size of the workspace (device_work) in bytes<ul>
<li>lwork[0] &lt; 0: a workspace query is assumed, the routine calculates the required amount of workspace and returns it in lwork. The workspace is not referenced, and no computation is performed.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>lwork[0] &gt;= 0: the routine assumes that the user has provided a workspace with the size in lwork.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">batchCount</td><td>INTEGER The number of matrices to operate on.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>magma_queue_t Queue to execute in.</td></tr>
  </table>
  </dd>
</dl>
<h1><a class="anchor" id="autotoc_md314"></a>
Further Details</h1>
<p>The band storage scheme is illustrated by the following example, when M = N = 6, KL = 2, KU = 1:</p>
<p>On entry: On exit: </p><pre class="fragment">     *    *    +    +    +       *    *    *   u14  u25  u36
     *    +    +    +    +       *    *   u13  u24  u35  u46
    a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56
</pre><p> a11 a22 a33 a44 a55 a66 u11 u22 u33 u44 u55 u66 a21 a32 a43 a54 a65 * m21 m32 m43 m54 m65 * a31 a42 a53 a64 * * m31 m42 m53 m64 * *</p>
<p>Array elements marked * are not used by the routine; elements marked</p><ul>
<li>need not be set on entry, but are required by the routine to store elements of U because of fill-in resulting from the row interchanges. </li>
</ul>

</div>
</div>
<a id="ga25783d18215714f60c0035dd54f04178" name="ga25783d18215714f60c0035dd54f04178"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga25783d18215714f60c0035dd54f04178">&#9670;&#160;</a></span>magma_cgbtrf_batched_sliding_window_loopin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_cgbtrf_batched_sliding_window_loopin </td>
          <td>(</td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>kl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ku</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex **&#160;</td>
          <td class="paramname"><em>dAB_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lddab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t **&#160;</td>
          <td class="paramname"><em>ipiv_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>batchCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmagma__queue.html">magma_queue_t</a>&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>CGBTRF computes an LU factorization of a COMPLEX m-by-n band matrix A using partial pivoting with row interchanges. </p>
<p>This is the batched version of the algorithm, which performs the factorization on a batch of matrices with the same size and lower/upper bandwidths.</p>
<p>This routine has shared memory requirements that may exceed the capacity of the GPU. In such a case, the routine exits immediately, returning a negative error code.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>INTEGER The number of rows of the matrix A. M &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>INTEGER The number of columns of the matrix A. N &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">KL</td><td>INTEGER The number of subdiagonals within the band of A. KL &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">KU</td><td>INTEGER The number of superdiagonals within the band of A. KU &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dAB_array</td><td>Array of pointers, dimension (batchCount). Each is a COMPLEX array, dimension (LDDAB,N) On entry, the matrix AB in band storage, in rows KL+1 to 2*KL+KU+1; rows 1 to KL of the array need not be set. The j-th column of A is stored in the j-th column of the array AB as follows: AB(kl+ku+1+i-j,j) = A(i,j) for max(1,j-ku)&lt;=i&lt;=min(m,j+kl)</td></tr>
  </table>
  </dd>
</dl>
<p>On exit, details of the factorization: U is stored as an upper triangular band matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and the multipliers used during the factorization are stored in rows KL+KU+2 to 2*KL+KU+1. See below for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">LDDAB</td><td>INTEGER The leading dimension of the array AB. LDAB &gt;= 2*KL+KU+1.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dIPIV_array</td><td>Array of pointers, dimension (batchCount). Each is an INTEGER array, dimension (min(M,N)) The pivot indices; for 1 &lt;= i &lt;= min(M,N), row i of the matrix was interchanged with row IPIV(i).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dINFO_array</td><td>INTEGER array, dimension (batchCount) Each is the INFO output for a given matrix = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value &gt; 0: if INFO = +i, U(i,i) is exactly zero. The factorization has been completed, but the factor U is exactly singular, and division by zero will occur if it is used to solve a system of equations.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">batchCount</td><td>INTEGER The number of matrices to operate on.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>magma_queue_t Queue to execute in.</td></tr>
  </table>
  </dd>
</dl>
<h1><a class="anchor" id="autotoc_md315"></a>
Further Details</h1>
<p>The band storage scheme is illustrated by the following example, when M = N = 6, KL = 2, KU = 1:</p>
<p>On entry: On exit: </p><pre class="fragment">     *    *    +    +    +       *    *    *   u14  u25  u36
     *    +    +    +    +       *    *   u13  u24  u35  u46
    a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56
</pre><p> a11 a22 a33 a44 a55 a66 u11 u22 u33 u44 u55 u66 a21 a32 a43 a54 a65 * m21 m32 m43 m54 m65 * a31 a42 a53 a64 * * m31 m42 m53 m64 * *</p>
<p>Array elements marked * are not used by the routine; elements marked</p><ul>
<li>need not be set on entry, but are required by the routine to store elements of U because of fill-in resulting from the row interchanges. </li>
</ul>

</div>
</div>
<a id="ga6b8635f3d4af0e161cfc74efd709381f" name="ga6b8635f3d4af0e161cfc74efd709381f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b8635f3d4af0e161cfc74efd709381f">&#9670;&#160;</a></span>magma_cgetf2_nopiv_internal_batched()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_cgetf2_nopiv_internal_batched </td>
          <td>(</td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex **&#160;</td>
          <td class="paramname"><em>dA_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ai</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>aj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>gbstep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>batchCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmagma__queue.html">magma_queue_t</a>&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>cgetf2_nopiv computes the non-pivoting LU factorization of an M-by-N matrix A. </p>
<p>This routine can deal with matrices of limited widths, so it is for internal use.</p>
<p>The factorization has the form A = L * U where L is lower triangular with unit diagonal elements (lower trapezoidal if m &gt; n), and U is upper triangular (upper trapezoidal if m &lt; n).</p>
<p>This is a batched version that factors batchCount M-by-N matrices in parallel.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>INTEGER The number of rows the matrix A. N &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>INTEGER The number of columns of the matrix A. N &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dA_array</td><td>Array of pointers, dimension (batchCount). Each is a COMPLEX array on the GPU, dimension (LDDA,N). On entry, each pointer is an M-by-N matrix to be factored. On exit, the factors L and U from the factorization A = L*U; the unit diagonal elements of L are not stored.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ai</td><td>INTEGER Row offset for dA_array.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aj</td><td>INTEGER Column offset for dA_array.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldda</td><td>INTEGER The leading dimension of each array A. LDDA &gt;= max(1,M).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info_array</td><td>Array of INTEGERs, dimension (batchCount), for corresponding matrices.<ul>
<li>= 0: successful exit</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value or another error occured, such as memory allocation failed.</li>
<li>&gt; 0: if INFO = i, U(i,i) is exactly zero. The factorization has been completed, but the factor U is exactly singular, and division by zero will occur if it is used to solve a system of equations.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gbstep</td><td>INTEGER Internal use.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">batchCount</td><td>INTEGER The number of matrices to operate on.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>magma_queue_t Queue to execute in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga056162626c59f65150c9b80a9e968f5a" name="ga056162626c59f65150c9b80a9e968f5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga056162626c59f65150c9b80a9e968f5a">&#9670;&#160;</a></span>magma_cgetrf_batched_smallsq_noshfl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_cgetrf_batched_smallsq_noshfl </td>
          <td>(</td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex **&#160;</td>
          <td class="paramname"><em>dA_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t **&#160;</td>
          <td class="paramname"><em>ipiv_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>batchCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmagma__queue.html">magma_queue_t</a>&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>cgetrf_batched_smallsq_noshfl computes the LU factorization of a square N-by-N matrix A using partial pivoting with row interchanges. </p>
<p>This routine can deal only with square matrices of size up to 32</p>
<p>The factorization has the form A = P * L * U where P is a permutation matrix, L is lower triangular with unit diagonal elements (lower trapezoidal if m &gt; n), and U is upper triangular (upper trapezoidal if m &lt; n).</p>
<p>This is the right-looking Level 3 BLAS version of the algorithm.</p>
<p>This is a batched version that factors batchCount M-by-N matrices in parallel. dA, ipiv, and info become arrays with one entry per matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>INTEGER The size of each matrix A. N &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dA_array</td><td>Array of pointers, dimension (batchCount). Each is a COMPLEX array on the GPU, dimension (LDDA,N). On entry, each pointer is an M-by-N matrix to be factored. On exit, the factors L and U from the factorization A = P*L*U; the unit diagonal elements of L are not stored.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldda</td><td>INTEGER The leading dimension of each array A. LDDA &gt;= max(1,M).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ipiv_array</td><td>Array of pointers, dimension (batchCount), for corresponding matrices. Each is an INTEGER array, dimension (min(M,N)) The pivot indices; for 1 &lt;= i &lt;= min(M,N), row i of the matrix was interchanged with row IPIV(i).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info_array</td><td>Array of INTEGERs, dimension (batchCount), for corresponding matrices.<ul>
<li>= 0: successful exit</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value or another error occured, such as memory allocation failed.</li>
<li>&gt; 0: if INFO = i, U(i,i) is exactly zero. The factorization has been completed, but the factor U is exactly singular, and division by zero will occur if it is used to solve a system of equations.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">batchCount</td><td>INTEGER The number of matrices to operate on.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>magma_queue_t Queue to execute in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab01b3805ed46bf82ce289b4515e04c3d" name="gab01b3805ed46bf82ce289b4515e04c3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab01b3805ed46bf82ce289b4515e04c3d">&#9670;&#160;</a></span>magma_dgbsv_batched_fused_sm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_dgbsv_batched_fused_sm </td>
          <td>(</td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>kl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ku</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>nrhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>dA_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t **&#160;</td>
          <td class="paramname"><em>ipiv_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>dB_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lddb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>nthreads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ntcol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>batchCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmagma__queue.html">magma_queue_t</a>&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DGBSV computes the solution to a system of linear equations A * X = B, where A is a band matrix of order N with KL subdiagonals and KU superdiagonals, and X and B are N-by-NRHS matrices. </p>
<p>The LU decomposition with partial pivoting and row interchanges is used to factor A as A = L * U, where L is a product of permutation and unit lower triangular matrices with KL subdiagonals, and U is upper triangular with KL+KU superdiagonals. The factored form of A is then used to solve the system of equations A * X = B.</p>
<p>This is the batched version of the routine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>INTEGER The order of the matrix A. n &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kl</td><td>INTEGER The number of subdiagonals within the band of A. KL &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ku</td><td>INTEGER The number of superdiagonals within the band of A. KL &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nrhs</td><td>INTEGER The number of right hand sides, i.e., the number of columns of the matrix B. NRHS &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dA_array</td><td>Array of pointers, dimension (batchCount). Each contains the details of the LU factorization of the band matrix A, as computed by DGBTRF. U is stored as an upper triangular band matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and the multipliers used during the factorization are stored in rows KL+KU+2 to 2*KL+KU+1.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldda</td><td>INTEGER The leading dimension of each array A. LDDA &gt;= (2*KL+KU+1).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dipiv_array</td><td>Array of pointers, dimension (batchCount), for corresponding matrices. Each is an INTEGER array, dimension (min(M,N)) The pivot indices; for 1 &lt;= i &lt;= min(M,N), row i of the matrix was interchanged with row IPIV(i).</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dB_array</td><td>Array of pointers, dimension (batchCount). Each is a DOUBLE PRECISION array, dimension (LDB,NRHS) On entry, the right hand side matrix B. On exit, the solution matrix X.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lddb</td><td>INTEGER The leading dimension of each array B. LDDB &gt;= max(1, N).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info_array</td><td>Array of INTEGERs, dimension (batchCount), for corresponding matrices.<ul>
<li>= 0: successful exit</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value or another error occured, such as memory allocation failed.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nthreads</td><td>INTEGER The number of threads assigned to a single matrix. nthreads &gt;= (KL+1)</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ntcol</td><td>INTEGER The number of concurrent factorizations in a thread-block ntcol &gt;= 1</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">batchCount</td><td>INTEGER The number of matrices to operate on.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>magma_queue_t Queue to execute in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa66ba9e089111eb1ade897064e59a105" name="gaa66ba9e089111eb1ade897064e59a105"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa66ba9e089111eb1ade897064e59a105">&#9670;&#160;</a></span>magma_dgbtrf_batched_fused_sm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_dgbtrf_batched_fused_sm </td>
          <td>(</td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>kl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ku</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>dAB_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lddab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t **&#160;</td>
          <td class="paramname"><em>ipiv_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>nthreads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ntcol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>batchCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmagma__queue.html">magma_queue_t</a>&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DGBTRF computes an LU factorization of a COMPLEX m-by-n band matrix A using partial pivoting with row interchanges. </p>
<p>This is the batched version of the algorithm, which performs the factorization on a batch of matrices with the same size and lower/upper bandwidths.</p>
<p>This routine has shared memory requirements that may exceed the capacity of the GPU. In such a case, the routine exits immediately, returning a negative error code.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>INTEGER The number of rows of the matrix A. M &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>INTEGER The number of columns of the matrix A. N &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">KL</td><td>INTEGER The number of subdiagonals within the band of A. KL &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">KU</td><td>INTEGER The number of superdiagonals within the band of A. KU &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dAB_array</td><td>Array of pointers, dimension (batchCount). Each is a DOUBLE PRECISION array, dimension (LDDAB,N) On entry, the matrix AB in band storage, in rows KL+1 to 2*KL+KU+1; rows 1 to KL of the array need not be set. The j-th column of A is stored in the j-th column of the array AB as follows: AB(kl+ku+1+i-j,j) = A(i,j) for max(1,j-ku)&lt;=i&lt;=min(m,j+kl)</td></tr>
  </table>
  </dd>
</dl>
<p>On exit, details of the factorization: U is stored as an upper triangular band matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and the multipliers used during the factorization are stored in rows KL+KU+2 to 2*KL+KU+1. See below for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">LDDAB</td><td>INTEGER The leading dimension of the array AB. LDAB &gt;= 2*KL+KU+1.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dIPIV_array</td><td>Array of pointers, dimension (batchCount). Each is an INTEGER array, dimension (min(M,N)) The pivot indices; for 1 &lt;= i &lt;= min(M,N), row i of the matrix was interchanged with row IPIV(i).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dINFO_array</td><td>INTEGER array, dimension (batchCount) Each is the INFO output for a given matrix = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value &gt; 0: if INFO = +i, U(i,i) is exactly zero. The factorization has been completed, but the factor U is exactly singular, and division by zero will occur if it is used to solve a system of equations.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nthreads</td><td>INTEGER The number of threads assigned to a single matrix. nthreads &gt;= (KL+1)</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ntcol</td><td>INTEGER The number of concurrent factorizations in a thread-block ntcol &gt;= 1</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">batchCount</td><td>INTEGER The number of matrices to operate on.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>magma_queue_t Queue to execute in.</td></tr>
  </table>
  </dd>
</dl>
<h2><a class="anchor" id="autotoc_md345"></a>
Further Details</h2>
<p>The band storage scheme is illustrated by the following example, when M = N = 6, KL = 2, KU = 1:</p>
<p>On entry: On exit: </p><pre class="fragment">   *    *    +    +    +       *    *    *   u14  u25  u36
   *    +    +    +    +       *    *   u13  u24  u35  u46
  a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56
</pre><p> a11 a22 a33 a44 a55 a66 u11 u22 u33 u44 u55 u66 a21 a32 a43 a54 a65 * m21 m32 m43 m54 m65 * a31 a42 a53 a64 * * m31 m42 m53 m64 * *</p>
<p>Array elements marked * are not used by the routine, but may be set to zero after completion. Elements marked</p><ul>
<li>need not be set on entry, but are required by the routine to store elements of U because of fill-in resulting from the row interchanges. </li>
</ul>

</div>
</div>
<a id="gade427e6a3fa4401d1eb5deccfdaad0bf" name="gade427e6a3fa4401d1eb5deccfdaad0bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade427e6a3fa4401d1eb5deccfdaad0bf">&#9670;&#160;</a></span>magma_dgbtrf_batched_sliding_window_loopout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_dgbtrf_batched_sliding_window_loopout </td>
          <td>(</td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>kl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ku</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>dAB_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lddab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t **&#160;</td>
          <td class="paramname"><em>ipiv_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>device_work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>batchCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmagma__queue.html">magma_queue_t</a>&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DGBTRF computes an LU factorization of a COMPLEX m-by-n band matrix A using partial pivoting with row interchanges. </p>
<p>This is the batched version of the algorithm, which performs the factorization on a batch of matrices with the same size and lower/upper bandwidths.</p>
<p>This routine has shared memory requirements that may exceed the capacity of the GPU. In such a case, the routine exits immediately, returning a negative error code.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>INTEGER The number of rows of the matrix A. M &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>INTEGER The number of columns of the matrix A. N &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">KL</td><td>INTEGER The number of subdiagonals within the band of A. KL &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">KU</td><td>INTEGER The number of superdiagonals within the band of A. KU &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dAB_array</td><td>Array of pointers, dimension (batchCount). Each is a DOUBLE PRECISION array, dimension (LDDAB,N) On entry, the matrix AB in band storage, in rows KL+1 to 2*KL+KU+1; rows 1 to KL of the array need not be set. The j-th column of A is stored in the j-th column of the array AB as follows: AB(kl+ku+1+i-j,j) = A(i,j) for max(1,j-ku)&lt;=i&lt;=min(m,j+kl)</td></tr>
  </table>
  </dd>
</dl>
<p>On exit, details of the factorization: U is stored as an upper triangular band matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and the multipliers used during the factorization are stored in rows KL+KU+2 to 2*KL+KU+1. See below for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">LDDAB</td><td>INTEGER The leading dimension of the array AB. LDAB &gt;= 2*KL+KU+1.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dIPIV_array</td><td>Array of pointers, dimension (batchCount). Each is an INTEGER array, dimension (min(M,N)) The pivot indices; for 1 &lt;= i &lt;= min(M,N), row i of the matrix was interchanged with row IPIV(i).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dINFO_array</td><td>INTEGER array, dimension (batchCount) Each is the INFO output for a given matrix = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value &gt; 0: if INFO = +i, U(i,i) is exactly zero. The factorization has been completed, but the factor U is exactly singular, and division by zero will occur if it is used to solve a system of equations.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">device_work</td><td>Workspace, allocated on device memory by the user</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lwork</td><td>INTEGER pointer The size of the workspace (device_work) in bytes<ul>
<li>lwork[0] &lt; 0: a workspace query is assumed, the routine calculates the required amount of workspace and returns it in lwork. The workspace is not referenced, and no computation is performed.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>lwork[0] &gt;= 0: the routine assumes that the user has provided a workspace with the size in lwork.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">batchCount</td><td>INTEGER The number of matrices to operate on.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>magma_queue_t Queue to execute in.</td></tr>
  </table>
  </dd>
</dl>
<h1><a class="anchor" id="autotoc_md346"></a>
Further Details</h1>
<p>The band storage scheme is illustrated by the following example, when M = N = 6, KL = 2, KU = 1:</p>
<p>On entry: On exit: </p><pre class="fragment">     *    *    +    +    +       *    *    *   u14  u25  u36
     *    +    +    +    +       *    *   u13  u24  u35  u46
    a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56
</pre><p> a11 a22 a33 a44 a55 a66 u11 u22 u33 u44 u55 u66 a21 a32 a43 a54 a65 * m21 m32 m43 m54 m65 * a31 a42 a53 a64 * * m31 m42 m53 m64 * *</p>
<p>Array elements marked * are not used by the routine; elements marked</p><ul>
<li>need not be set on entry, but are required by the routine to store elements of U because of fill-in resulting from the row interchanges. </li>
</ul>

</div>
</div>
<a id="gaa6f8c98a9c177fea9622e1e14b58754a" name="gaa6f8c98a9c177fea9622e1e14b58754a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa6f8c98a9c177fea9622e1e14b58754a">&#9670;&#160;</a></span>magma_dgbtrf_batched_sliding_window_loopin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_dgbtrf_batched_sliding_window_loopin </td>
          <td>(</td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>kl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ku</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>dAB_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lddab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t **&#160;</td>
          <td class="paramname"><em>ipiv_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>batchCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmagma__queue.html">magma_queue_t</a>&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DGBTRF computes an LU factorization of a COMPLEX m-by-n band matrix A using partial pivoting with row interchanges. </p>
<p>This is the batched version of the algorithm, which performs the factorization on a batch of matrices with the same size and lower/upper bandwidths.</p>
<p>This routine has shared memory requirements that may exceed the capacity of the GPU. In such a case, the routine exits immediately, returning a negative error code.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>INTEGER The number of rows of the matrix A. M &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>INTEGER The number of columns of the matrix A. N &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">KL</td><td>INTEGER The number of subdiagonals within the band of A. KL &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">KU</td><td>INTEGER The number of superdiagonals within the band of A. KU &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dAB_array</td><td>Array of pointers, dimension (batchCount). Each is a DOUBLE PRECISION array, dimension (LDDAB,N) On entry, the matrix AB in band storage, in rows KL+1 to 2*KL+KU+1; rows 1 to KL of the array need not be set. The j-th column of A is stored in the j-th column of the array AB as follows: AB(kl+ku+1+i-j,j) = A(i,j) for max(1,j-ku)&lt;=i&lt;=min(m,j+kl)</td></tr>
  </table>
  </dd>
</dl>
<p>On exit, details of the factorization: U is stored as an upper triangular band matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and the multipliers used during the factorization are stored in rows KL+KU+2 to 2*KL+KU+1. See below for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">LDDAB</td><td>INTEGER The leading dimension of the array AB. LDAB &gt;= 2*KL+KU+1.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dIPIV_array</td><td>Array of pointers, dimension (batchCount). Each is an INTEGER array, dimension (min(M,N)) The pivot indices; for 1 &lt;= i &lt;= min(M,N), row i of the matrix was interchanged with row IPIV(i).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dINFO_array</td><td>INTEGER array, dimension (batchCount) Each is the INFO output for a given matrix = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value &gt; 0: if INFO = +i, U(i,i) is exactly zero. The factorization has been completed, but the factor U is exactly singular, and division by zero will occur if it is used to solve a system of equations.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">batchCount</td><td>INTEGER The number of matrices to operate on.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>magma_queue_t Queue to execute in.</td></tr>
  </table>
  </dd>
</dl>
<h1><a class="anchor" id="autotoc_md347"></a>
Further Details</h1>
<p>The band storage scheme is illustrated by the following example, when M = N = 6, KL = 2, KU = 1:</p>
<p>On entry: On exit: </p><pre class="fragment">     *    *    +    +    +       *    *    *   u14  u25  u36
     *    +    +    +    +       *    *   u13  u24  u35  u46
    a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56
</pre><p> a11 a22 a33 a44 a55 a66 u11 u22 u33 u44 u55 u66 a21 a32 a43 a54 a65 * m21 m32 m43 m54 m65 * a31 a42 a53 a64 * * m31 m42 m53 m64 * *</p>
<p>Array elements marked * are not used by the routine; elements marked</p><ul>
<li>need not be set on entry, but are required by the routine to store elements of U because of fill-in resulting from the row interchanges. </li>
</ul>

</div>
</div>
<a id="gab8d797324a846e8a356b7a9dc2d5fa99" name="gab8d797324a846e8a356b7a9dc2d5fa99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab8d797324a846e8a356b7a9dc2d5fa99">&#9670;&#160;</a></span>magma_dgetf2_nopiv_internal_batched()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_dgetf2_nopiv_internal_batched </td>
          <td>(</td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>dA_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ai</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>aj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>gbstep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>batchCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmagma__queue.html">magma_queue_t</a>&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>dgetf2_nopiv computes the non-pivoting LU factorization of an M-by-N matrix A. </p>
<p>This routine can deal with matrices of limited widths, so it is for internal use.</p>
<p>The factorization has the form A = L * U where L is lower triangular with unit diagonal elements (lower trapezoidal if m &gt; n), and U is upper triangular (upper trapezoidal if m &lt; n).</p>
<p>This is a batched version that factors batchCount M-by-N matrices in parallel.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>INTEGER The number of rows the matrix A. N &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>INTEGER The number of columns of the matrix A. N &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dA_array</td><td>Array of pointers, dimension (batchCount). Each is a DOUBLE PRECISION array on the GPU, dimension (LDDA,N). On entry, each pointer is an M-by-N matrix to be factored. On exit, the factors L and U from the factorization A = L*U; the unit diagonal elements of L are not stored.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ai</td><td>INTEGER Row offset for dA_array.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aj</td><td>INTEGER Column offset for dA_array.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldda</td><td>INTEGER The leading dimension of each array A. LDDA &gt;= max(1,M).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info_array</td><td>Array of INTEGERs, dimension (batchCount), for corresponding matrices.<ul>
<li>= 0: successful exit</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value or another error occured, such as memory allocation failed.</li>
<li>&gt; 0: if INFO = i, U(i,i) is exactly zero. The factorization has been completed, but the factor U is exactly singular, and division by zero will occur if it is used to solve a system of equations.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gbstep</td><td>INTEGER Internal use.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">batchCount</td><td>INTEGER The number of matrices to operate on.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>magma_queue_t Queue to execute in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga29efea15394a7e827c7ebc3f8e9a33a6" name="ga29efea15394a7e827c7ebc3f8e9a33a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga29efea15394a7e827c7ebc3f8e9a33a6">&#9670;&#160;</a></span>magma_dgetrf_batched_smallsq_noshfl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_dgetrf_batched_smallsq_noshfl </td>
          <td>(</td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>dA_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t **&#160;</td>
          <td class="paramname"><em>ipiv_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>batchCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmagma__queue.html">magma_queue_t</a>&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>dgetrf_batched_smallsq_noshfl computes the LU factorization of a square N-by-N matrix A using partial pivoting with row interchanges. </p>
<p>This routine can deal only with square matrices of size up to 32</p>
<p>The factorization has the form A = P * L * U where P is a permutation matrix, L is lower triangular with unit diagonal elements (lower trapezoidal if m &gt; n), and U is upper triangular (upper trapezoidal if m &lt; n).</p>
<p>This is the right-looking Level 3 BLAS version of the algorithm.</p>
<p>This is a batched version that factors batchCount M-by-N matrices in parallel. dA, ipiv, and info become arrays with one entry per matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>INTEGER The size of each matrix A. N &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dA_array</td><td>Array of pointers, dimension (batchCount). Each is a DOUBLE PRECISION array on the GPU, dimension (LDDA,N). On entry, each pointer is an M-by-N matrix to be factored. On exit, the factors L and U from the factorization A = P*L*U; the unit diagonal elements of L are not stored.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldda</td><td>INTEGER The leading dimension of each array A. LDDA &gt;= max(1,M).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ipiv_array</td><td>Array of pointers, dimension (batchCount), for corresponding matrices. Each is an INTEGER array, dimension (min(M,N)) The pivot indices; for 1 &lt;= i &lt;= min(M,N), row i of the matrix was interchanged with row IPIV(i).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info_array</td><td>Array of INTEGERs, dimension (batchCount), for corresponding matrices.<ul>
<li>= 0: successful exit</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value or another error occured, such as memory allocation failed.</li>
<li>&gt; 0: if INFO = i, U(i,i) is exactly zero. The factorization has been completed, but the factor U is exactly singular, and division by zero will occur if it is used to solve a system of equations.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">batchCount</td><td>INTEGER The number of matrices to operate on.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>magma_queue_t Queue to execute in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaed9b8e9d701d4472c326c14d273c08fb" name="gaed9b8e9d701d4472c326c14d273c08fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaed9b8e9d701d4472c326c14d273c08fb">&#9670;&#160;</a></span>magma_sgbsv_batched_fused_sm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_sgbsv_batched_fused_sm </td>
          <td>(</td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>kl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ku</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>nrhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float **&#160;</td>
          <td class="paramname"><em>dA_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t **&#160;</td>
          <td class="paramname"><em>ipiv_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float **&#160;</td>
          <td class="paramname"><em>dB_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lddb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>nthreads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ntcol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>batchCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmagma__queue.html">magma_queue_t</a>&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SGBSV computes the solution to a system of linear equations A * X = B, where A is a band matrix of order N with KL subdiagonals and KU superdiagonals, and X and B are N-by-NRHS matrices. </p>
<p>The LU decomposition with partial pivoting and row interchanges is used to factor A as A = L * U, where L is a product of permutation and unit lower triangular matrices with KL subdiagonals, and U is upper triangular with KL+KU superdiagonals. The factored form of A is then used to solve the system of equations A * X = B.</p>
<p>This is the batched version of the routine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>INTEGER The order of the matrix A. n &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kl</td><td>INTEGER The number of subdiagonals within the band of A. KL &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ku</td><td>INTEGER The number of superdiagonals within the band of A. KL &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nrhs</td><td>INTEGER The number of right hand sides, i.e., the number of columns of the matrix B. NRHS &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dA_array</td><td>Array of pointers, dimension (batchCount). Each contains the details of the LU factorization of the band matrix A, as computed by SGBTRF. U is stored as an upper triangular band matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and the multipliers used during the factorization are stored in rows KL+KU+2 to 2*KL+KU+1.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldda</td><td>INTEGER The leading dimension of each array A. LDDA &gt;= (2*KL+KU+1).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dipiv_array</td><td>Array of pointers, dimension (batchCount), for corresponding matrices. Each is an INTEGER array, dimension (min(M,N)) The pivot indices; for 1 &lt;= i &lt;= min(M,N), row i of the matrix was interchanged with row IPIV(i).</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dB_array</td><td>Array of pointers, dimension (batchCount). Each is a REAL array, dimension (LDB,NRHS) On entry, the right hand side matrix B. On exit, the solution matrix X.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lddb</td><td>INTEGER The leading dimension of each array B. LDDB &gt;= max(1, N).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info_array</td><td>Array of INTEGERs, dimension (batchCount), for corresponding matrices.<ul>
<li>= 0: successful exit</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value or another error occured, such as memory allocation failed.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nthreads</td><td>INTEGER The number of threads assigned to a single matrix. nthreads &gt;= (KL+1)</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ntcol</td><td>INTEGER The number of concurrent factorizations in a thread-block ntcol &gt;= 1</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">batchCount</td><td>INTEGER The number of matrices to operate on.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>magma_queue_t Queue to execute in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga55fdce37833793cac7968482d25a27a6" name="ga55fdce37833793cac7968482d25a27a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga55fdce37833793cac7968482d25a27a6">&#9670;&#160;</a></span>magma_sgbtrf_batched_fused_sm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_sgbtrf_batched_fused_sm </td>
          <td>(</td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>kl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ku</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float **&#160;</td>
          <td class="paramname"><em>dAB_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lddab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t **&#160;</td>
          <td class="paramname"><em>ipiv_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>nthreads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ntcol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>batchCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmagma__queue.html">magma_queue_t</a>&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SGBTRF computes an LU factorization of a COMPLEX m-by-n band matrix A using partial pivoting with row interchanges. </p>
<p>This is the batched version of the algorithm, which performs the factorization on a batch of matrices with the same size and lower/upper bandwidths.</p>
<p>This routine has shared memory requirements that may exceed the capacity of the GPU. In such a case, the routine exits immediately, returning a negative error code.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>INTEGER The number of rows of the matrix A. M &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>INTEGER The number of columns of the matrix A. N &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">KL</td><td>INTEGER The number of subdiagonals within the band of A. KL &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">KU</td><td>INTEGER The number of superdiagonals within the band of A. KU &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dAB_array</td><td>Array of pointers, dimension (batchCount). Each is a REAL array, dimension (LDDAB,N) On entry, the matrix AB in band storage, in rows KL+1 to 2*KL+KU+1; rows 1 to KL of the array need not be set. The j-th column of A is stored in the j-th column of the array AB as follows: AB(kl+ku+1+i-j,j) = A(i,j) for max(1,j-ku)&lt;=i&lt;=min(m,j+kl)</td></tr>
  </table>
  </dd>
</dl>
<p>On exit, details of the factorization: U is stored as an upper triangular band matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and the multipliers used during the factorization are stored in rows KL+KU+2 to 2*KL+KU+1. See below for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">LDDAB</td><td>INTEGER The leading dimension of the array AB. LDAB &gt;= 2*KL+KU+1.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dIPIV_array</td><td>Array of pointers, dimension (batchCount). Each is an INTEGER array, dimension (min(M,N)) The pivot indices; for 1 &lt;= i &lt;= min(M,N), row i of the matrix was interchanged with row IPIV(i).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dINFO_array</td><td>INTEGER array, dimension (batchCount) Each is the INFO output for a given matrix = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value &gt; 0: if INFO = +i, U(i,i) is exactly zero. The factorization has been completed, but the factor U is exactly singular, and division by zero will occur if it is used to solve a system of equations.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nthreads</td><td>INTEGER The number of threads assigned to a single matrix. nthreads &gt;= (KL+1)</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ntcol</td><td>INTEGER The number of concurrent factorizations in a thread-block ntcol &gt;= 1</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">batchCount</td><td>INTEGER The number of matrices to operate on.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>magma_queue_t Queue to execute in.</td></tr>
  </table>
  </dd>
</dl>
<h2><a class="anchor" id="autotoc_md378"></a>
Further Details</h2>
<p>The band storage scheme is illustrated by the following example, when M = N = 6, KL = 2, KU = 1:</p>
<p>On entry: On exit: </p><pre class="fragment">   *    *    +    +    +       *    *    *   u14  u25  u36
   *    +    +    +    +       *    *   u13  u24  u35  u46
  a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56
</pre><p> a11 a22 a33 a44 a55 a66 u11 u22 u33 u44 u55 u66 a21 a32 a43 a54 a65 * m21 m32 m43 m54 m65 * a31 a42 a53 a64 * * m31 m42 m53 m64 * *</p>
<p>Array elements marked * are not used by the routine, but may be set to zero after completion. Elements marked</p><ul>
<li>need not be set on entry, but are required by the routine to store elements of U because of fill-in resulting from the row interchanges. </li>
</ul>

</div>
</div>
<a id="gadba9fd8a2d613a921353a0595b764113" name="gadba9fd8a2d613a921353a0595b764113"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadba9fd8a2d613a921353a0595b764113">&#9670;&#160;</a></span>magma_sgbtrf_batched_sliding_window_loopout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_sgbtrf_batched_sliding_window_loopout </td>
          <td>(</td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>kl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ku</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float **&#160;</td>
          <td class="paramname"><em>dAB_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lddab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t **&#160;</td>
          <td class="paramname"><em>ipiv_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>device_work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>batchCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmagma__queue.html">magma_queue_t</a>&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SGBTRF computes an LU factorization of a COMPLEX m-by-n band matrix A using partial pivoting with row interchanges. </p>
<p>This is the batched version of the algorithm, which performs the factorization on a batch of matrices with the same size and lower/upper bandwidths.</p>
<p>This routine has shared memory requirements that may exceed the capacity of the GPU. In such a case, the routine exits immediately, returning a negative error code.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>INTEGER The number of rows of the matrix A. M &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>INTEGER The number of columns of the matrix A. N &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">KL</td><td>INTEGER The number of subdiagonals within the band of A. KL &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">KU</td><td>INTEGER The number of superdiagonals within the band of A. KU &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dAB_array</td><td>Array of pointers, dimension (batchCount). Each is a REAL array, dimension (LDDAB,N) On entry, the matrix AB in band storage, in rows KL+1 to 2*KL+KU+1; rows 1 to KL of the array need not be set. The j-th column of A is stored in the j-th column of the array AB as follows: AB(kl+ku+1+i-j,j) = A(i,j) for max(1,j-ku)&lt;=i&lt;=min(m,j+kl)</td></tr>
  </table>
  </dd>
</dl>
<p>On exit, details of the factorization: U is stored as an upper triangular band matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and the multipliers used during the factorization are stored in rows KL+KU+2 to 2*KL+KU+1. See below for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">LDDAB</td><td>INTEGER The leading dimension of the array AB. LDAB &gt;= 2*KL+KU+1.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dIPIV_array</td><td>Array of pointers, dimension (batchCount). Each is an INTEGER array, dimension (min(M,N)) The pivot indices; for 1 &lt;= i &lt;= min(M,N), row i of the matrix was interchanged with row IPIV(i).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dINFO_array</td><td>INTEGER array, dimension (batchCount) Each is the INFO output for a given matrix = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value &gt; 0: if INFO = +i, U(i,i) is exactly zero. The factorization has been completed, but the factor U is exactly singular, and division by zero will occur if it is used to solve a system of equations.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">device_work</td><td>Workspace, allocated on device memory by the user</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lwork</td><td>INTEGER pointer The size of the workspace (device_work) in bytes<ul>
<li>lwork[0] &lt; 0: a workspace query is assumed, the routine calculates the required amount of workspace and returns it in lwork. The workspace is not referenced, and no computation is performed.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>lwork[0] &gt;= 0: the routine assumes that the user has provided a workspace with the size in lwork.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">batchCount</td><td>INTEGER The number of matrices to operate on.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>magma_queue_t Queue to execute in.</td></tr>
  </table>
  </dd>
</dl>
<h1><a class="anchor" id="autotoc_md379"></a>
Further Details</h1>
<p>The band storage scheme is illustrated by the following example, when M = N = 6, KL = 2, KU = 1:</p>
<p>On entry: On exit: </p><pre class="fragment">     *    *    +    +    +       *    *    *   u14  u25  u36
     *    +    +    +    +       *    *   u13  u24  u35  u46
    a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56
</pre><p> a11 a22 a33 a44 a55 a66 u11 u22 u33 u44 u55 u66 a21 a32 a43 a54 a65 * m21 m32 m43 m54 m65 * a31 a42 a53 a64 * * m31 m42 m53 m64 * *</p>
<p>Array elements marked * are not used by the routine; elements marked</p><ul>
<li>need not be set on entry, but are required by the routine to store elements of U because of fill-in resulting from the row interchanges. </li>
</ul>

</div>
</div>
<a id="ga8e40200eaec9b1f83606af85309c54aa" name="ga8e40200eaec9b1f83606af85309c54aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8e40200eaec9b1f83606af85309c54aa">&#9670;&#160;</a></span>magma_sgbtrf_batched_sliding_window_loopin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_sgbtrf_batched_sliding_window_loopin </td>
          <td>(</td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>kl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ku</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float **&#160;</td>
          <td class="paramname"><em>dAB_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lddab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t **&#160;</td>
          <td class="paramname"><em>ipiv_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>batchCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmagma__queue.html">magma_queue_t</a>&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SGBTRF computes an LU factorization of a COMPLEX m-by-n band matrix A using partial pivoting with row interchanges. </p>
<p>This is the batched version of the algorithm, which performs the factorization on a batch of matrices with the same size and lower/upper bandwidths.</p>
<p>This routine has shared memory requirements that may exceed the capacity of the GPU. In such a case, the routine exits immediately, returning a negative error code.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>INTEGER The number of rows of the matrix A. M &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>INTEGER The number of columns of the matrix A. N &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">KL</td><td>INTEGER The number of subdiagonals within the band of A. KL &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">KU</td><td>INTEGER The number of superdiagonals within the band of A. KU &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dAB_array</td><td>Array of pointers, dimension (batchCount). Each is a REAL array, dimension (LDDAB,N) On entry, the matrix AB in band storage, in rows KL+1 to 2*KL+KU+1; rows 1 to KL of the array need not be set. The j-th column of A is stored in the j-th column of the array AB as follows: AB(kl+ku+1+i-j,j) = A(i,j) for max(1,j-ku)&lt;=i&lt;=min(m,j+kl)</td></tr>
  </table>
  </dd>
</dl>
<p>On exit, details of the factorization: U is stored as an upper triangular band matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and the multipliers used during the factorization are stored in rows KL+KU+2 to 2*KL+KU+1. See below for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">LDDAB</td><td>INTEGER The leading dimension of the array AB. LDAB &gt;= 2*KL+KU+1.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dIPIV_array</td><td>Array of pointers, dimension (batchCount). Each is an INTEGER array, dimension (min(M,N)) The pivot indices; for 1 &lt;= i &lt;= min(M,N), row i of the matrix was interchanged with row IPIV(i).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dINFO_array</td><td>INTEGER array, dimension (batchCount) Each is the INFO output for a given matrix = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value &gt; 0: if INFO = +i, U(i,i) is exactly zero. The factorization has been completed, but the factor U is exactly singular, and division by zero will occur if it is used to solve a system of equations.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">batchCount</td><td>INTEGER The number of matrices to operate on.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>magma_queue_t Queue to execute in.</td></tr>
  </table>
  </dd>
</dl>
<h1><a class="anchor" id="autotoc_md380"></a>
Further Details</h1>
<p>The band storage scheme is illustrated by the following example, when M = N = 6, KL = 2, KU = 1:</p>
<p>On entry: On exit: </p><pre class="fragment">     *    *    +    +    +       *    *    *   u14  u25  u36
     *    +    +    +    +       *    *   u13  u24  u35  u46
    a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56
</pre><p> a11 a22 a33 a44 a55 a66 u11 u22 u33 u44 u55 u66 a21 a32 a43 a54 a65 * m21 m32 m43 m54 m65 * a31 a42 a53 a64 * * m31 m42 m53 m64 * *</p>
<p>Array elements marked * are not used by the routine; elements marked</p><ul>
<li>need not be set on entry, but are required by the routine to store elements of U because of fill-in resulting from the row interchanges. </li>
</ul>

</div>
</div>
<a id="ga67737def4165c9a35af9ff1eeef4c529" name="ga67737def4165c9a35af9ff1eeef4c529"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga67737def4165c9a35af9ff1eeef4c529">&#9670;&#160;</a></span>magma_sgetf2_nopiv_internal_batched()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_sgetf2_nopiv_internal_batched </td>
          <td>(</td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float **&#160;</td>
          <td class="paramname"><em>dA_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ai</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>aj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>gbstep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>batchCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmagma__queue.html">magma_queue_t</a>&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>sgetf2_nopiv computes the non-pivoting LU factorization of an M-by-N matrix A. </p>
<p>This routine can deal with matrices of limited widths, so it is for internal use.</p>
<p>The factorization has the form A = L * U where L is lower triangular with unit diagonal elements (lower trapezoidal if m &gt; n), and U is upper triangular (upper trapezoidal if m &lt; n).</p>
<p>This is a batched version that factors batchCount M-by-N matrices in parallel.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>INTEGER The number of rows the matrix A. N &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>INTEGER The number of columns of the matrix A. N &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dA_array</td><td>Array of pointers, dimension (batchCount). Each is a REAL array on the GPU, dimension (LDDA,N). On entry, each pointer is an M-by-N matrix to be factored. On exit, the factors L and U from the factorization A = L*U; the unit diagonal elements of L are not stored.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ai</td><td>INTEGER Row offset for dA_array.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aj</td><td>INTEGER Column offset for dA_array.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldda</td><td>INTEGER The leading dimension of each array A. LDDA &gt;= max(1,M).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info_array</td><td>Array of INTEGERs, dimension (batchCount), for corresponding matrices.<ul>
<li>= 0: successful exit</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value or another error occured, such as memory allocation failed.</li>
<li>&gt; 0: if INFO = i, U(i,i) is exactly zero. The factorization has been completed, but the factor U is exactly singular, and division by zero will occur if it is used to solve a system of equations.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gbstep</td><td>INTEGER Internal use.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">batchCount</td><td>INTEGER The number of matrices to operate on.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>magma_queue_t Queue to execute in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga532da9fac258f0baaba28a38f19f7bdf" name="ga532da9fac258f0baaba28a38f19f7bdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga532da9fac258f0baaba28a38f19f7bdf">&#9670;&#160;</a></span>magma_sgetrf_batched_smallsq_noshfl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_sgetrf_batched_smallsq_noshfl </td>
          <td>(</td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float **&#160;</td>
          <td class="paramname"><em>dA_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t **&#160;</td>
          <td class="paramname"><em>ipiv_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>batchCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmagma__queue.html">magma_queue_t</a>&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>sgetrf_batched_smallsq_noshfl computes the LU factorization of a square N-by-N matrix A using partial pivoting with row interchanges. </p>
<p>This routine can deal only with square matrices of size up to 32</p>
<p>The factorization has the form A = P * L * U where P is a permutation matrix, L is lower triangular with unit diagonal elements (lower trapezoidal if m &gt; n), and U is upper triangular (upper trapezoidal if m &lt; n).</p>
<p>This is the right-looking Level 3 BLAS version of the algorithm.</p>
<p>This is a batched version that factors batchCount M-by-N matrices in parallel. dA, ipiv, and info become arrays with one entry per matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>INTEGER The size of each matrix A. N &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dA_array</td><td>Array of pointers, dimension (batchCount). Each is a REAL array on the GPU, dimension (LDDA,N). On entry, each pointer is an M-by-N matrix to be factored. On exit, the factors L and U from the factorization A = P*L*U; the unit diagonal elements of L are not stored.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldda</td><td>INTEGER The leading dimension of each array A. LDDA &gt;= max(1,M).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ipiv_array</td><td>Array of pointers, dimension (batchCount), for corresponding matrices. Each is an INTEGER array, dimension (min(M,N)) The pivot indices; for 1 &lt;= i &lt;= min(M,N), row i of the matrix was interchanged with row IPIV(i).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info_array</td><td>Array of INTEGERs, dimension (batchCount), for corresponding matrices.<ul>
<li>= 0: successful exit</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value or another error occured, such as memory allocation failed.</li>
<li>&gt; 0: if INFO = i, U(i,i) is exactly zero. The factorization has been completed, but the factor U is exactly singular, and division by zero will occur if it is used to solve a system of equations.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">batchCount</td><td>INTEGER The number of matrices to operate on.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>magma_queue_t Queue to execute in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaef70b4926971c3b3e486ad28ab57cfc7" name="gaef70b4926971c3b3e486ad28ab57cfc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef70b4926971c3b3e486ad28ab57cfc7">&#9670;&#160;</a></span>magma_zgbsv_batched_fused_sm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_zgbsv_batched_fused_sm </td>
          <td>(</td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>kl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ku</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>nrhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaDoubleComplex **&#160;</td>
          <td class="paramname"><em>dA_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t **&#160;</td>
          <td class="paramname"><em>ipiv_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaDoubleComplex **&#160;</td>
          <td class="paramname"><em>dB_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lddb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>nthreads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ntcol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>batchCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmagma__queue.html">magma_queue_t</a>&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ZGBSV computes the solution to a system of linear equations A * X = B, where A is a band matrix of order N with KL subdiagonals and KU superdiagonals, and X and B are N-by-NRHS matrices. </p>
<p>The LU decomposition with partial pivoting and row interchanges is used to factor A as A = L * U, where L is a product of permutation and unit lower triangular matrices with KL subdiagonals, and U is upper triangular with KL+KU superdiagonals. The factored form of A is then used to solve the system of equations A * X = B.</p>
<p>This is the batched version of the routine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>INTEGER The order of the matrix A. n &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kl</td><td>INTEGER The number of subdiagonals within the band of A. KL &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ku</td><td>INTEGER The number of superdiagonals within the band of A. KL &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nrhs</td><td>INTEGER The number of right hand sides, i.e., the number of columns of the matrix B. NRHS &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dA_array</td><td>Array of pointers, dimension (batchCount). Each contains the details of the LU factorization of the band matrix A, as computed by ZGBTRF. U is stored as an upper triangular band matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and the multipliers used during the factorization are stored in rows KL+KU+2 to 2*KL+KU+1.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldda</td><td>INTEGER The leading dimension of each array A. LDDA &gt;= (2*KL+KU+1).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dipiv_array</td><td>Array of pointers, dimension (batchCount), for corresponding matrices. Each is an INTEGER array, dimension (min(M,N)) The pivot indices; for 1 &lt;= i &lt;= min(M,N), row i of the matrix was interchanged with row IPIV(i).</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dB_array</td><td>Array of pointers, dimension (batchCount). Each is a COMPLEX*16 array, dimension (LDB,NRHS) On entry, the right hand side matrix B. On exit, the solution matrix X.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lddb</td><td>INTEGER The leading dimension of each array B. LDDB &gt;= max(1, N).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info_array</td><td>Array of INTEGERs, dimension (batchCount), for corresponding matrices.<ul>
<li>= 0: successful exit</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value or another error occured, such as memory allocation failed.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nthreads</td><td>INTEGER The number of threads assigned to a single matrix. nthreads &gt;= (KL+1)</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ntcol</td><td>INTEGER The number of concurrent factorizations in a thread-block ntcol &gt;= 1</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">batchCount</td><td>INTEGER The number of matrices to operate on.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>magma_queue_t Queue to execute in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga332dcd218102adcba76d8ec9f70f5e23" name="ga332dcd218102adcba76d8ec9f70f5e23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga332dcd218102adcba76d8ec9f70f5e23">&#9670;&#160;</a></span>magma_zgbtrf_batched_fused_sm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_zgbtrf_batched_fused_sm </td>
          <td>(</td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>kl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ku</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaDoubleComplex **&#160;</td>
          <td class="paramname"><em>dAB_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lddab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t **&#160;</td>
          <td class="paramname"><em>ipiv_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>nthreads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ntcol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>batchCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmagma__queue.html">magma_queue_t</a>&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ZGBTRF computes an LU factorization of a COMPLEX m-by-n band matrix A using partial pivoting with row interchanges. </p>
<p>This is the batched version of the algorithm, which performs the factorization on a batch of matrices with the same size and lower/upper bandwidths.</p>
<p>This routine has shared memory requirements that may exceed the capacity of the GPU. In such a case, the routine exits immediately, returning a negative error code.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>INTEGER The number of rows of the matrix A. M &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>INTEGER The number of columns of the matrix A. N &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">KL</td><td>INTEGER The number of subdiagonals within the band of A. KL &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">KU</td><td>INTEGER The number of superdiagonals within the band of A. KU &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dAB_array</td><td>Array of pointers, dimension (batchCount). Each is a COMPLEX_16 array, dimension (LDDAB,N) On entry, the matrix AB in band storage, in rows KL+1 to 2*KL+KU+1; rows 1 to KL of the array need not be set. The j-th column of A is stored in the j-th column of the array AB as follows: AB(kl+ku+1+i-j,j) = A(i,j) for max(1,j-ku)&lt;=i&lt;=min(m,j+kl)</td></tr>
  </table>
  </dd>
</dl>
<p>On exit, details of the factorization: U is stored as an upper triangular band matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and the multipliers used during the factorization are stored in rows KL+KU+2 to 2*KL+KU+1. See below for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">LDDAB</td><td>INTEGER The leading dimension of the array AB. LDAB &gt;= 2*KL+KU+1.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dIPIV_array</td><td>Array of pointers, dimension (batchCount). Each is an INTEGER array, dimension (min(M,N)) The pivot indices; for 1 &lt;= i &lt;= min(M,N), row i of the matrix was interchanged with row IPIV(i).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dINFO_array</td><td>INTEGER array, dimension (batchCount) Each is the INFO output for a given matrix = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value &gt; 0: if INFO = +i, U(i,i) is exactly zero. The factorization has been completed, but the factor U is exactly singular, and division by zero will occur if it is used to solve a system of equations.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nthreads</td><td>INTEGER The number of threads assigned to a single matrix. nthreads &gt;= (KL+1)</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ntcol</td><td>INTEGER The number of concurrent factorizations in a thread-block ntcol &gt;= 1</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">batchCount</td><td>INTEGER The number of matrices to operate on.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>magma_queue_t Queue to execute in.</td></tr>
  </table>
  </dd>
</dl>
<h2><a class="anchor" id="autotoc_md407"></a>
Further Details</h2>
<p>The band storage scheme is illustrated by the following example, when M = N = 6, KL = 2, KU = 1:</p>
<p>On entry: On exit: </p><pre class="fragment">   *    *    +    +    +       *    *    *   u14  u25  u36
   *    +    +    +    +       *    *   u13  u24  u35  u46
  a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56
</pre><p> a11 a22 a33 a44 a55 a66 u11 u22 u33 u44 u55 u66 a21 a32 a43 a54 a65 * m21 m32 m43 m54 m65 * a31 a42 a53 a64 * * m31 m42 m53 m64 * *</p>
<p>Array elements marked * are not used by the routine, but may be set to zero after completion. Elements marked</p><ul>
<li>need not be set on entry, but are required by the routine to store elements of U because of fill-in resulting from the row interchanges. </li>
</ul>

</div>
</div>
<a id="gab43e864ff87ac5581f40a4647f64026c" name="gab43e864ff87ac5581f40a4647f64026c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab43e864ff87ac5581f40a4647f64026c">&#9670;&#160;</a></span>magma_zgbtrf_batched_sliding_window_loopout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_zgbtrf_batched_sliding_window_loopout </td>
          <td>(</td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>kl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ku</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaDoubleComplex **&#160;</td>
          <td class="paramname"><em>dAB_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lddab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t **&#160;</td>
          <td class="paramname"><em>ipiv_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>device_work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>batchCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmagma__queue.html">magma_queue_t</a>&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ZGBTRF computes an LU factorization of a COMPLEX m-by-n band matrix A using partial pivoting with row interchanges. </p>
<p>This is the batched version of the algorithm, which performs the factorization on a batch of matrices with the same size and lower/upper bandwidths.</p>
<p>This routine has shared memory requirements that may exceed the capacity of the GPU. In such a case, the routine exits immediately, returning a negative error code.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>INTEGER The number of rows of the matrix A. M &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>INTEGER The number of columns of the matrix A. N &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">KL</td><td>INTEGER The number of subdiagonals within the band of A. KL &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">KU</td><td>INTEGER The number of superdiagonals within the band of A. KU &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dAB_array</td><td>Array of pointers, dimension (batchCount). Each is a COMPLEX_16 array, dimension (LDDAB,N) On entry, the matrix AB in band storage, in rows KL+1 to 2*KL+KU+1; rows 1 to KL of the array need not be set. The j-th column of A is stored in the j-th column of the array AB as follows: AB(kl+ku+1+i-j,j) = A(i,j) for max(1,j-ku)&lt;=i&lt;=min(m,j+kl)</td></tr>
  </table>
  </dd>
</dl>
<p>On exit, details of the factorization: U is stored as an upper triangular band matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and the multipliers used during the factorization are stored in rows KL+KU+2 to 2*KL+KU+1. See below for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">LDDAB</td><td>INTEGER The leading dimension of the array AB. LDAB &gt;= 2*KL+KU+1.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dIPIV_array</td><td>Array of pointers, dimension (batchCount). Each is an INTEGER array, dimension (min(M,N)) The pivot indices; for 1 &lt;= i &lt;= min(M,N), row i of the matrix was interchanged with row IPIV(i).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dINFO_array</td><td>INTEGER array, dimension (batchCount) Each is the INFO output for a given matrix = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value &gt; 0: if INFO = +i, U(i,i) is exactly zero. The factorization has been completed, but the factor U is exactly singular, and division by zero will occur if it is used to solve a system of equations.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">device_work</td><td>Workspace, allocated on device memory by the user</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lwork</td><td>INTEGER pointer The size of the workspace (device_work) in bytes<ul>
<li>lwork[0] &lt; 0: a workspace query is assumed, the routine calculates the required amount of workspace and returns it in lwork. The workspace is not referenced, and no computation is performed.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>lwork[0] &gt;= 0: the routine assumes that the user has provided a workspace with the size in lwork.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">batchCount</td><td>INTEGER The number of matrices to operate on.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>magma_queue_t Queue to execute in.</td></tr>
  </table>
  </dd>
</dl>
<h1><a class="anchor" id="autotoc_md408"></a>
Further Details</h1>
<p>The band storage scheme is illustrated by the following example, when M = N = 6, KL = 2, KU = 1:</p>
<p>On entry: On exit: </p><pre class="fragment">     *    *    +    +    +       *    *    *   u14  u25  u36
     *    +    +    +    +       *    *   u13  u24  u35  u46
    a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56
</pre><p> a11 a22 a33 a44 a55 a66 u11 u22 u33 u44 u55 u66 a21 a32 a43 a54 a65 * m21 m32 m43 m54 m65 * a31 a42 a53 a64 * * m31 m42 m53 m64 * *</p>
<p>Array elements marked * are not used by the routine; elements marked</p><ul>
<li>need not be set on entry, but are required by the routine to store elements of U because of fill-in resulting from the row interchanges. </li>
</ul>

</div>
</div>
<a id="ga76ea175718812162c68fa57b6a3f6ffd" name="ga76ea175718812162c68fa57b6a3f6ffd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga76ea175718812162c68fa57b6a3f6ffd">&#9670;&#160;</a></span>magma_zgbtrf_batched_sliding_window_loopin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_zgbtrf_batched_sliding_window_loopin </td>
          <td>(</td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>kl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ku</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaDoubleComplex **&#160;</td>
          <td class="paramname"><em>dAB_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lddab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t **&#160;</td>
          <td class="paramname"><em>ipiv_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>batchCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmagma__queue.html">magma_queue_t</a>&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ZGBTRF computes an LU factorization of a COMPLEX m-by-n band matrix A using partial pivoting with row interchanges. </p>
<p>This is the batched version of the algorithm, which performs the factorization on a batch of matrices with the same size and lower/upper bandwidths.</p>
<p>This routine has shared memory requirements that may exceed the capacity of the GPU. In such a case, the routine exits immediately, returning a negative error code.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>INTEGER The number of rows of the matrix A. M &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>INTEGER The number of columns of the matrix A. N &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">KL</td><td>INTEGER The number of subdiagonals within the band of A. KL &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">KU</td><td>INTEGER The number of superdiagonals within the band of A. KU &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dAB_array</td><td>Array of pointers, dimension (batchCount). Each is a COMPLEX_16 array, dimension (LDDAB,N) On entry, the matrix AB in band storage, in rows KL+1 to 2*KL+KU+1; rows 1 to KL of the array need not be set. The j-th column of A is stored in the j-th column of the array AB as follows: AB(kl+ku+1+i-j,j) = A(i,j) for max(1,j-ku)&lt;=i&lt;=min(m,j+kl)</td></tr>
  </table>
  </dd>
</dl>
<p>On exit, details of the factorization: U is stored as an upper triangular band matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and the multipliers used during the factorization are stored in rows KL+KU+2 to 2*KL+KU+1. See below for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">LDDAB</td><td>INTEGER The leading dimension of the array AB. LDAB &gt;= 2*KL+KU+1.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dIPIV_array</td><td>Array of pointers, dimension (batchCount). Each is an INTEGER array, dimension (min(M,N)) The pivot indices; for 1 &lt;= i &lt;= min(M,N), row i of the matrix was interchanged with row IPIV(i).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dINFO_array</td><td>INTEGER array, dimension (batchCount) Each is the INFO output for a given matrix = 0: successful exit &lt; 0: if INFO = -i, the i-th argument had an illegal value &gt; 0: if INFO = +i, U(i,i) is exactly zero. The factorization has been completed, but the factor U is exactly singular, and division by zero will occur if it is used to solve a system of equations.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">batchCount</td><td>INTEGER The number of matrices to operate on.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>magma_queue_t Queue to execute in.</td></tr>
  </table>
  </dd>
</dl>
<h1><a class="anchor" id="autotoc_md409"></a>
Further Details</h1>
<p>The band storage scheme is illustrated by the following example, when M = N = 6, KL = 2, KU = 1:</p>
<p>On entry: On exit: </p><pre class="fragment">     *    *    +    +    +       *    *    *   u14  u25  u36
     *    +    +    +    +       *    *   u13  u24  u35  u46
    a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56
</pre><p> a11 a22 a33 a44 a55 a66 u11 u22 u33 u44 u55 u66 a21 a32 a43 a54 a65 * m21 m32 m43 m54 m65 * a31 a42 a53 a64 * * m31 m42 m53 m64 * *</p>
<p>Array elements marked * are not used by the routine; elements marked</p><ul>
<li>need not be set on entry, but are required by the routine to store elements of U because of fill-in resulting from the row interchanges. </li>
</ul>

</div>
</div>
<a id="ga351030f7d65ed12639f7601eefb62254" name="ga351030f7d65ed12639f7601eefb62254"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga351030f7d65ed12639f7601eefb62254">&#9670;&#160;</a></span>magma_zgetf2_nopiv_internal_batched()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_zgetf2_nopiv_internal_batched </td>
          <td>(</td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaDoubleComplex **&#160;</td>
          <td class="paramname"><em>dA_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ai</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>aj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>gbstep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>batchCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmagma__queue.html">magma_queue_t</a>&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>zgetf2_nopiv computes the non-pivoting LU factorization of an M-by-N matrix A. </p>
<p>This routine can deal with matrices of limited widths, so it is for internal use.</p>
<p>The factorization has the form A = L * U where L is lower triangular with unit diagonal elements (lower trapezoidal if m &gt; n), and U is upper triangular (upper trapezoidal if m &lt; n).</p>
<p>This is a batched version that factors batchCount M-by-N matrices in parallel.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>INTEGER The number of rows the matrix A. N &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>INTEGER The number of columns of the matrix A. N &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dA_array</td><td>Array of pointers, dimension (batchCount). Each is a COMPLEX_16 array on the GPU, dimension (LDDA,N). On entry, each pointer is an M-by-N matrix to be factored. On exit, the factors L and U from the factorization A = L*U; the unit diagonal elements of L are not stored.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ai</td><td>INTEGER Row offset for dA_array.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aj</td><td>INTEGER Column offset for dA_array.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldda</td><td>INTEGER The leading dimension of each array A. LDDA &gt;= max(1,M).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info_array</td><td>Array of INTEGERs, dimension (batchCount), for corresponding matrices.<ul>
<li>= 0: successful exit</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value or another error occured, such as memory allocation failed.</li>
<li>&gt; 0: if INFO = i, U(i,i) is exactly zero. The factorization has been completed, but the factor U is exactly singular, and division by zero will occur if it is used to solve a system of equations.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gbstep</td><td>INTEGER Internal use.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">batchCount</td><td>INTEGER The number of matrices to operate on.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>magma_queue_t Queue to execute in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab2a92e4171bbb5128c25c767df760011" name="gab2a92e4171bbb5128c25c767df760011"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab2a92e4171bbb5128c25c767df760011">&#9670;&#160;</a></span>magma_zgetrf_batched_smallsq_noshfl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_zgetrf_batched_smallsq_noshfl </td>
          <td>(</td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaDoubleComplex **&#160;</td>
          <td class="paramname"><em>dA_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t **&#160;</td>
          <td class="paramname"><em>ipiv_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>batchCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmagma__queue.html">magma_queue_t</a>&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>zgetrf_batched_smallsq_noshfl computes the LU factorization of a square N-by-N matrix A using partial pivoting with row interchanges. </p>
<p>This routine can deal only with square matrices of size up to 32</p>
<p>The factorization has the form A = P * L * U where P is a permutation matrix, L is lower triangular with unit diagonal elements (lower trapezoidal if m &gt; n), and U is upper triangular (upper trapezoidal if m &lt; n).</p>
<p>This is the right-looking Level 3 BLAS version of the algorithm.</p>
<p>This is a batched version that factors batchCount M-by-N matrices in parallel. dA, ipiv, and info become arrays with one entry per matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>INTEGER The size of each matrix A. N &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dA_array</td><td>Array of pointers, dimension (batchCount). Each is a COMPLEX_16 array on the GPU, dimension (LDDA,N). On entry, each pointer is an M-by-N matrix to be factored. On exit, the factors L and U from the factorization A = P*L*U; the unit diagonal elements of L are not stored.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldda</td><td>INTEGER The leading dimension of each array A. LDDA &gt;= max(1,M).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ipiv_array</td><td>Array of pointers, dimension (batchCount), for corresponding matrices. Each is an INTEGER array, dimension (min(M,N)) The pivot indices; for 1 &lt;= i &lt;= min(M,N), row i of the matrix was interchanged with row IPIV(i).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info_array</td><td>Array of INTEGERs, dimension (batchCount), for corresponding matrices.<ul>
<li>= 0: successful exit</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value or another error occured, such as memory allocation failed.</li>
<li>&gt; 0: if INFO = i, U(i,i) is exactly zero. The factorization has been completed, but the factor U is exactly singular, and division by zero will occur if it is used to solve a system of equations.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">batchCount</td><td>INTEGER The number of matrices to operate on.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>magma_queue_t Queue to execute in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
